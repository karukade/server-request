/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({}[chunkId]||chunkId) + ".chunk.js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/core-js/internals/a-function.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-function.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/core-js/internals/an-instance.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/an-instance.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js"); // `Array.prototype.{ indexOf, includes }` methods implementation


var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};

/***/ }),

/***/ "./node_modules/core-js/internals/bind-context.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/bind-context.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js"); // optional / simple context binding


module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 0:
      return function () {
        return fn.call(that);
      };

    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js"); // call something on iterator step with safe closing on error


module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return {
        done: !!called++
      };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };

  iteratorWithReturn[ITERATOR] = function () {
    return this;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {
  /* empty */
}

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;

  try {
    var object = {};

    object[ITERATOR] = function () {
      return {
        next: function () {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };

    exec(object);
  } catch (error) {
    /* empty */
  }

  return ITERATION_SUPPORT;
};

/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");

var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag'); // ES3 wrong here

var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) {
    /* empty */
  }
}; // getting tag from ES6+ `Object.prototype.toString`


module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");

var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");

var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js"); // Thank's IE8 for his funny defineProperty


module.exports = !fails(function () {
  return Object.defineProperty({}, 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = global.document; // typeof document.createElement is 'object' in old IE

var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");

var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");

var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/


module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;

  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }

  if (target) for (key in source) {
    sourceProperty = source[key];

    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];

    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    } // add a flag to not completely full polyfills


    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    } // extend global


    redefine(target, key, sourceProperty, options);
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};

/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {
  return it && it.Math == Math && it;
}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


module.exports = // eslint-disable-next-line no-undef
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof global == 'object' && global) || // eslint-disable-next-line no-new-func
Function('return this')();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-js/internals/has.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/has.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "./node_modules/core-js/internals/host-report-errors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/host-report-errors.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = function (a, b) {
  var console = global.console;

  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');

/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js"); // Thank's IE8 for his funny defineProperty


module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

/***/ }),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

var functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper

if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;

/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;

    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    }

    return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = new WeakMap();
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;

  set = function (it, metadata) {
    wmset.call(store, it, metadata);
    return metadata;
  };

  get = function (it) {
    return wmget.call(store, it) || {};
  };

  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;

  set = function (it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };

  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };

  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

/***/ }),

/***/ "./node_modules/core-js/internals/is-array-iterator-method.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype; // check on default Array iterator

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
module.exports = isForced;

/***/ }),

/***/ "./node_modules/core-js/internals/is-ios.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/is-ios.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__(/*! ../internals/user-agent */ "./node_modules/core-js/internals/user-agent.js");

module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);

/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),

/***/ "./node_modules/core-js/internals/iterate.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/iterate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");

var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
  var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);
  var iterator, iterFn, index, length, result, next, step;

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators

    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
        if (result && result instanceof Result) return result;
      }

      return new Result(false);
    }

    iterator = iterFn.call(iterable);
  }

  next = iterator.next;

  while (!(step = next.call(iterator)).done) {
    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
    if (typeof result == 'object' && result && result instanceof Result) return result;
  }

  return new Result(false);
};

iterate.stop = function (result) {
  return new Result(true, result);
};

/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "./node_modules/core-js/internals/microtask.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/microtask.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var macrotask = __webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js").set;

var IS_IOS = __webpack_require__(/*! ../internals/is-ios */ "./node_modules/core-js/internals/is-ios.js");

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var IS_NODE = classof(process) == 'process'; // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`

var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush, head, last, notify, toggle, node, promise, then; // modern engines have queueMicrotask method

if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (error) {
        if (head) notify();else last = undefined;
        throw error;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // Node.js


  if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    }; // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339

  } else if (MutationObserver && !IS_IOS) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, {
      characterData: true
    });

    notify = function () {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    then = promise.then;

    notify = function () {
      then.call(promise, flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = {
    fn: fn,
    next: undefined
  };
  if (last) last.next = task;

  if (!head) {
    head = task;
    notify();
  }

  last = task;
};

/***/ }),

/***/ "./node_modules/core-js/internals/native-promise-constructor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/native-promise-constructor.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = global.Promise;

/***/ }),

/***/ "./node_modules/core-js/internals/native-symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});

/***/ }),

/***/ "./node_modules/core-js/internals/native-weak-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var WeakMap = global.WeakMap;
module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

/***/ }),

/***/ "./node_modules/core-js/internals/new-promise-capability.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/new-promise-capability.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}; // 25.4.1.5 NewPromiseCapability(C)


module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");

var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty

exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");

var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) {
    /* empty */
  }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");

var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");

var indexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf;

var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key); // Don't enum bug & hidden keys


  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }

  return result;
};

/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
  1: 2
}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

/***/ }),

/***/ "./node_modules/core-js/internals/object-to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js"); // `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring


module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};

/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");

var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js"); // all object keys, includes non-enumerable and symbols


module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

/***/ }),

/***/ "./node_modules/core-js/internals/path.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = global;

/***/ }),

/***/ "./node_modules/core-js/internals/perform.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/perform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return {
      error: false,
      value: exec()
    };
  } catch (error) {
    return {
      error: true,
      value: error
    };
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/promise-resolve.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/promise-resolve.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var newPromiseCapability = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),

/***/ "./node_modules/core-js/internals/redefine-all.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/redefine-all.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);

  return target;
};

/***/ }),

/***/ "./node_modules/core-js/internals/redefine.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");

var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');
(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;

  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }

  if (O === global) {
    if (simple) O[key] = value;else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }

  if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});

/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/internals/set-global.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  }

  return value;
};

/***/ }),

/***/ "./node_modules/core-js/internals/set-species.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/set-species.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () {
        return this;
      }
    });
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, {
      configurable: true,
      value: TAG
    });
  }
};

/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");

var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

/***/ }),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});
module.exports = store;

/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.6.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ "./node_modules/core-js/internals/species-constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/species-constructor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor

module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};

/***/ }),

/***/ "./node_modules/core-js/internals/task.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/task.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");

var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");

var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

var IS_IOS = __webpack_require__(/*! ../internals/is-ios */ "./node_modules/core-js/internals/is-ios.js");

var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(id + '', location.protocol + '//' + location.host);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) args.push(arguments[i++]);

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };

    defer(counter);
    return counter;
  };

  clear = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (classof(process) == 'process') {
    defer = function (id) {
      process.nextTick(runner(id));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    }; // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624

  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && !fails(post)) {
    defer = post;
    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    }; // Rest old browsers

  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var max = Math.max;
var min = Math.min; // Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-integer.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor; // `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger

module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var min = Math.min; // `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength

module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js"); // `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "./node_modules/core-js/internals/to-string-tag-support.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};
test[TO_STRING_TAG] = 'z';
module.exports = String(test) === '[object z]';

/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

/***/ }),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

module.exports = NATIVE_SYMBOL // eslint-disable-next-line no-undef
&& !Symbol.sham // eslint-disable-next-line no-undef
&& typeof Symbol.iterator == 'symbol';

/***/ }),

/***/ "./node_modules/core-js/internals/user-agent.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/user-agent.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('navigator', 'userAgent') || '';

/***/ }),

/***/ "./node_modules/core-js/internals/v8-version.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/v8-version.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var userAgent = __webpack_require__(/*! ../internals/user-agent */ "./node_modules/core-js/internals/user-agent.js");

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);

  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;

/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  }

  return WellKnownSymbolsStore[name];
};

/***/ }),

/***/ "./node_modules/core-js/modules/es.object.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js"); // `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring


if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, {
    unsafe: true
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es.promise.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

var NativePromise = __webpack_require__(/*! ../internals/native-promise-constructor */ "./node_modules/core-js/internals/native-promise-constructor.js");

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");

var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");

var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");

var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");

var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");

var task = __webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js").set;

var microtask = __webpack_require__(/*! ../internals/microtask */ "./node_modules/core-js/internals/microtask.js");

var promiseResolve = __webpack_require__(/*! ../internals/promise-resolve */ "./node_modules/core-js/internals/promise-resolve.js");

var hostReportErrors = __webpack_require__(/*! ../internals/host-report-errors */ "./node_modules/core-js/internals/host-report-errors.js");

var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");

var perform = __webpack_require__(/*! ../internals/perform */ "./node_modules/core-js/internals/perform.js");

var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var V8_VERSION = __webpack_require__(/*! ../internals/v8-version */ "./node_modules/core-js/internals/v8-version.js");

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var IS_NODE = classof(process) == 'process';
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
var FORCED = isForced(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);

  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (V8_VERSION === 66) return true; // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test

    if (!IS_NODE && typeof PromiseRejectionEvent != 'function') return true;
  } // We need Promise#finally in the pure version for preventing prototype pollution


  if (IS_PURE && !PromiseConstructor.prototype['finally']) return true; // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679

  if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false; // Detect correctness of subclassing with @@species support

  var promise = PromiseConstructor.resolve(1);

  var FakePromise = function (exec) {
    exec(function () {
      /* empty */
    }, function () {
      /* empty */
    });
  };

  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  return !(promise.then(function () {
    /* empty */
  }) instanceof FakePromise);
});
var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () {
    /* empty */
  });
}); // helpers

var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0; // variable length - can't use forEach

    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
            state.rejection = HANDLED;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // can throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }

    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(promise, state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;

  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = {
    promise: promise,
    reason: reason
  };

  if (handler = global['on' + name]) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (promise, state) {
  task.call(global, function () {
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;

    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (promise, state) {
  task.call(global, function () {
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, promise, state, unwrap) {
  return function (value) {
    fn(promise, state, value, unwrap);
  };
};

var internalReject = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(promise, state, true);
};

var internalResolve = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;

  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);

    if (then) {
      microtask(function () {
        var wrapper = {
          done: false
        };

        try {
          then.call(value, bind(internalResolve, promise, wrapper, state), bind(internalReject, promise, wrapper, state));
        } catch (error) {
          internalReject(promise, wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(promise, state, false);
    }
  } catch (error) {
    internalReject(promise, {
      done: false
    }, error, state);
  }
}; // constructor polyfill


if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);

    try {
      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
    } catch (error) {
      internalReject(this, state, error);
    }
  }; // eslint-disable-next-line no-unused-vars


  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };

  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(this, state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, promise, state);
    this.reject = bind(internalReject, promise, state);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && typeof NativePromise == 'function') {
    nativeThen = NativePromise.prototype.then; // wrap native Promise#then for native async functions

    redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected); // https://github.com/zloirock/core-js/issues/640
    }, {
      unsafe: true
    }); // wrap fetch result

    if (typeof $fetch == 'function') $({
      global: true,
      enumerable: true,
      forced: true
    }, {
      // eslint-disable-next-line no-unused-vars
      fetch: function fetch(input
      /* , init */
      ) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
      }
    });
  }
}

$({
  global: true,
  wrap: true,
  forced: FORCED
}, {
  Promise: PromiseConstructor
});
setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);
PromiseWrapper = getBuiltIn(PROMISE); // statics

$({
  target: PROMISE,
  stat: true,
  forced: FORCED
}, {
  // `Promise.reject` method
  // https://tc39.github.io/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});
$({
  target: PROMISE,
  stat: true,
  forced: IS_PURE || FORCED
}, {
  // `Promise.resolve` method
  // https://tc39.github.io/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});
$({
  target: PROMISE,
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  // `Promise.all` method
  // https://tc39.github.io/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.github.io/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/assets/global.scss":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/assets/global.scss ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "@charset \"UTF-8\";\n/*!\n * ress.css • v2.0.2\n * MIT License\n * github.com/filipelinhares/ress\n */\n/* # =================================================================\n   # Global selectors\n   # ================================================================= */\nhtml {\n  box-sizing: border-box;\n  -webkit-text-size-adjust: 100%;\n  /* Prevent adjustments of font size after orientation changes in iOS */\n  word-break: break-word;\n  -moz-tab-size: 4;\n  tab-size: 4; }\n\n*,\n::before,\n::after {\n  background-repeat: no-repeat;\n  /* Set `background-repeat: no-repeat` to all elements and pseudo elements */\n  box-sizing: inherit; }\n\n::before,\n::after {\n  text-decoration: inherit;\n  /* Inherit text-decoration and vertical align to ::before and ::after pseudo elements */\n  vertical-align: inherit; }\n\n* {\n  padding: 0;\n  /* Reset `padding` and `margin` of all elements */\n  margin: 0; }\n\n/* # =================================================================\n     # General elements\n     # ================================================================= */\nhr {\n  overflow: visible;\n  /* Show the overflow in Edge and IE */\n  height: 0;\n  /* Add the correct box sizing in Firefox */ }\n\ndetails,\nmain {\n  display: block;\n  /* Render the `main` element consistently in IE. */ }\n\nsummary {\n  display: list-item;\n  /* Add the correct display in all browsers */ }\n\nsmall {\n  font-size: 80%;\n  /* Set font-size to 80% in `small` elements */ }\n\n[hidden] {\n  display: none;\n  /* Add the correct display in IE */ }\n\nabbr[title] {\n  border-bottom: none;\n  /* Remove the bottom border in Chrome 57 */\n  /* Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari */\n  text-decoration: underline;\n  text-decoration: underline dotted; }\n\na {\n  background-color: transparent;\n  /* Remove the gray background on active links in IE 10 */ }\n\na:active,\na:hover {\n  outline-width: 0;\n  /* Remove the outline when hovering in all browsers */ }\n\ncode,\nkbd,\npre,\nsamp {\n  font-family: monospace, monospace;\n  /* Specify the font family of code elements */ }\n\npre {\n  font-size: 1em;\n  /* Correct the odd `em` font sizing in all browsers */ }\n\nb,\nstrong {\n  font-weight: bolder;\n  /* Add the correct font weight in Chrome, Edge, and Safari */ }\n\n/* https://gist.github.com/unruthless/413930 */\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline; }\n\nsub {\n  bottom: -0.25em; }\n\nsup {\n  top: -0.5em; }\n\n/* # =================================================================\n     # Forms\n     # ================================================================= */\ninput {\n  border-radius: 0; }\n\n/* Replace pointer cursor in disabled elements */\n[disabled] {\n  cursor: default; }\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n  /* Correct the cursor style of increment and decrement buttons in Chrome */ }\n\n[type=\"search\"] {\n  -webkit-appearance: textfield;\n  /* Correct the odd appearance in Chrome and Safari */\n  outline-offset: -2px; }\n\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n  /* Remove the inner padding in Chrome and Safari on macOS */ }\n\ntextarea {\n  overflow: auto;\n  /* Internet Explorer 11+ */\n  resize: vertical;\n  /* Specify textarea resizability */ }\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font: inherit;\n  /* Specify font inheritance of form elements */ }\n\noptgroup {\n  font-weight: bold;\n  /* Restore the font weight unset by the previous rule */ }\n\nbutton {\n  overflow: visible;\n  /* Address `overflow` set to `hidden` in IE 8/9/10/11 */ }\n\nbutton,\nselect {\n  text-transform: none;\n  /* Firefox 40+, Internet Explorer 11- */ }\n\n/* Apply cursor pointer to button elements */\nbutton,\n[type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"],\n[role=\"button\"] {\n  cursor: pointer;\n  color: inherit; }\n\n/* Remove inner padding and border in Firefox 4+ */\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0; }\n\n/* Replace focus style removed in the border reset above */\nbutton:-moz-focusring,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  outline: 1px dotted ButtonText; }\n\nbutton,\nhtml [type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button;\n  /* Correct the inability to style clickable types in iOS */ }\n\n/* Remove the default button styling in all browsers */\nbutton,\ninput,\nselect,\ntextarea {\n  background-color: transparent;\n  border-style: none; }\n\n/* Style select like a standard input */\nselect {\n  -moz-appearance: none;\n  /* Firefox 36+ */\n  -webkit-appearance: none;\n  /* Chrome 41+ */ }\n\nselect::-ms-expand {\n  display: none;\n  /* Internet Explorer 11+ */ }\n\nselect::-ms-value {\n  color: currentColor;\n  /* Internet Explorer 11+ */ }\n\nlegend {\n  border: 0;\n  /* Correct `color` not being inherited in IE 8/9/10/11 */\n  color: inherit;\n  /* Correct the color inheritance from `fieldset` elements in IE */\n  display: table;\n  /* Correct the text wrapping in Edge and IE */\n  max-width: 100%;\n  /* Correct the text wrapping in Edge and IE */\n  white-space: normal;\n  /* Correct the text wrapping in Edge and IE */\n  max-width: 100%;\n  /* Correct the text wrapping in Edge 18- and IE */ }\n\n::-webkit-file-upload-button {\n  /* Correct the inability to style clickable types in iOS and Safari */\n  -webkit-appearance: button;\n  color: inherit;\n  font: inherit;\n  /* Change font properties to `inherit` in Chrome and Safari */ }\n\n/* # =================================================================\n     # Specify media element style\n     # ================================================================= */\nimg {\n  border-style: none;\n  /* Remove border when inside `a` element in IE 8/9/10 */ }\n\n/* Add the correct vertical alignment in Chrome, Firefox, and Opera */\nprogress {\n  vertical-align: baseline; }\n\nsvg:not([fill]) {\n  fill: currentColor; }\n\n/* # =================================================================\n     # Accessibility\n     # ================================================================= */\n/* Hide content from screens but not screenreaders */\n@media screen {\n  [hidden~=\"screen\"] {\n    display: inherit; }\n  [hidden~=\"screen\"]:not(:active):not(:focus):not(:target) {\n    position: absolute !important;\n    clip: rect(0 0 0 0) !important; } }\n\n/* Specify the progress cursor of updating elements */\n[aria-busy=\"true\"] {\n  cursor: progress; }\n\n/* Specify the pointer cursor of trigger elements */\n[aria-controls] {\n  cursor: pointer; }\n\n/* Specify the unstyled cursor of disabled, not-editable, or otherwise inoperable elements */\n[aria-disabled] {\n  cursor: default; }\n\nbody {\n  font-family: apple-system,BlinkMacSystemFont,\"Hiragino Sans\",\"Hiragino Kaku Gothic ProN\",\"ヒラギノ角ゴ ProN W3\",\"メイリオ\",Meiryo,sans-serif;\n  color: #333; }\n  body * {\n    box-sizing: border-box; }\n\nlabel {\n  display: block; }\n\n.container {\n  padding: 40px 0 0;\n  max-width: 600px;\n  margin-left: auto;\n  margin-right: auto; }\n\n.form-wrapper > * + * {\n  margin-top: 18px; }\n\n.form-wrapper + .form-wrapper {\n  margin-top: 42px; }\n\n.btn-wrap {\n  text-align: center; }\n\n.btn-wrap-right {\n  text-align: right; }\n\n.btn {\n  display: inline-block;\n  background: #000;\n  font-weight: bold;\n  padding: 16px;\n  min-width: 300px;\n  border-radius: 4px;\n  color: #fff;\n  font-size: 18px; }\n  .btn:disabled {\n    opacity: 0.1; }\n\n.btn-secondary {\n  display: inline-block;\n  background: #fff;\n  border: #eee solid 2px;\n  padding: 10px;\n  min-width: 160px;\n  border-radius: 4px;\n  color: #333;\n  font-size: 16px; }\n  .btn-secondary:disabled {\n    opacity: 0.1; }\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names

module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    for (var i = 0; i < modules.length; i++) {
      var item = [].concat(modules[i]);

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : undefined);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function (handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function (event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function (handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function (handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function (handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function (handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/App.vue?vue&type=template&id=7ba5bd90&":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/App.vue?vue&type=template&id=7ba5bd90& ***!
  \**********************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "container" }, [_c("router-view")], 1)
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "./node_modules/vue-router/dist/vue-router.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/vue-router/dist/vue-router.esm.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*!
  * vue-router v3.1.3
  * (c) 2019 Evan You
  * @license MIT
  */

/*  */
function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if ( true && !condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

function isError(err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1;
}

function isExtendedError(constructor, err) {
  return err instanceof constructor || // _name is to support IE9 too
  err && (err.name === constructor.name || err._name === constructor._name);
}

function extend(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }

  return a;
}

var View = {
  name: 'RouterView',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data; // used by devtools to display a router-view badge

    data.routerView = true; // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots

    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {}); // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.

    var depth = 0;
    var inactive = false;

    while (parent && parent._routerRoot !== parent) {
      var vnodeData = parent.$vnode && parent.$vnode.data;

      if (vnodeData) {
        if (vnodeData.routerView) {
          depth++;
        }

        if (vnodeData.keepAlive && parent._inactive) {
          inactive = true;
        }
      }

      parent = parent.$parent;
    }

    data.routerViewDepth = depth; // render previous view if the tree is inactive and kept-alive

    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth]; // render empty node if no matched route

    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name]; // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks

    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];

      if (val && current !== vm || !val && current === vm) {
        matched.instances[name] = val;
      }
    } // also register instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;

    (data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    }; // register instance in init hook
    // in case kept-alive component be actived when routes changed


    data.hook.init = function (vnode) {
      if (vnode.data.keepAlive && vnode.componentInstance && vnode.componentInstance !== matched.instances[name]) {
        matched.instances[name] = vnode.componentInstance;
      }
    }; // resolve props


    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);

    if (propsToPass) {
      // clone to prevent mutation
      propsToPass = data.props = extend({}, propsToPass); // pass non-declared props as attrs

      var attrs = data.attrs = data.attrs || {};

      for (var key in propsToPass) {
        if (!component.props || !(key in component.props)) {
          attrs[key] = propsToPass[key];
          delete propsToPass[key];
        }
      }
    }

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config) {
    case 'undefined':
      return;

    case 'object':
      return config;

    case 'function':
      return config(route);

    case 'boolean':
      return config ? route.params : undefined;

    default:
      if (true) {
        warn(false, "props in \"" + route.path + "\" is a " + typeof config + ", " + "expecting an object, function or boolean.");
      }

  }
}
/*  */


var encodeReserveRE = /[!'()*]/g;

var encodeReserveReplacer = function (c) {
  return '%' + c.charCodeAt(0).toString(16);
};

var commaRE = /%2C/g; // fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas

var encode = function (str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery, _parseQuery) {
  if (extraQuery === void 0) extraQuery = {};
  var parse = _parseQuery || parseQuery;
  var parsedQuery;

  try {
    parsedQuery = parse(query || '');
  } catch (e) {
     true && warn(false, e.message);
    parsedQuery = {};
  }

  for (var key in extraQuery) {
    parsedQuery[key] = extraQuery[key];
  }

  return parsedQuery;
}

function parseQuery(query) {
  var res = {};
  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });
  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }

        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}
/*  */


var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom, router) {
  var stringifyQuery = router && router.options.stringifyQuery;
  var query = location.query || {};

  try {
    query = clone(query);
  } catch (e) {}

  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery),
    matched: record ? formatMatch(record) : []
  };

  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery);
  }

  return Object.freeze(route);
}

function clone(value) {
  if (Array.isArray(value)) {
    return value.map(clone);
  } else if (value && typeof value === 'object') {
    var res = {};

    for (var key in value) {
      res[key] = clone(value[key]);
    }

    return res;
  } else {
    return value;
  }
} // the starting route that represents the initial state


var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];

  while (record) {
    res.unshift(record);
    record = record.parent;
  }

  return res;
}

function getFullPath(ref, _stringifyQuery) {
  var path = ref.path;
  var query = ref.query;
  if (query === void 0) query = {};
  var hash = ref.hash;
  if (hash === void 0) hash = '';
  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {}; // handle null value #1566

  if (!a || !b) {
    return a === b;
  }

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);

  if (aKeys.length !== bKeys.length) {
    return false;
  }

  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key]; // check nested equality

    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal);
    }

    return String(aVal) === String(bVal);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }

  return true;
}
/*  */


function resolvePath(relative, base, append) {
  var firstChar = relative.charAt(0);

  if (firstChar === '/') {
    return relative;
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative;
  }

  var stack = base.split('/'); // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)

  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  } // resolve relative path


  var segments = relative.replace(/^\//, '').split('/');

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];

    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  } // ensure leading slash


  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';
  var hashIndex = path.indexOf('#');

  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');

  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};
/**
 * Expose `pathToRegexp`.
 */


var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;
/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */

var PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)', // Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');
/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */

function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length; // Ignore already escaped sequences.

    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7]; // Push the current path onto the tokens.

    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;
    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  } // Match any characters still remaining.


  if (index < str.length) {
    path += str.substr(index);
  } // If the path exists, push it onto the end.


  if (path) {
    tokens.push(path);
  }

  return tokens;
}
/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */


function compile(str, options) {
  return tokensToFunction(parse(str, options));
}
/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */


function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */


function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
/**
 * Expose a method for transforming tokens into the path function.
 */


function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length); // Compile all the patterns before compilation.

  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;
        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}
/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */


function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}
/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */


function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}
/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */


function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}
/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */


function flags(options) {
  return options.sensitive ? '' : 'i';
}
/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */


function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}
/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */


function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys);
}
/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */


function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */


function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options =
    /** @type {!Object} */
    keys || options;
    keys = [];
  }

  options = options || {};
  var strict = options.strict;
  var end = options.end !== false;
  var route = ''; // Iterate over the tokens and create our regexp string.

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';
      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter; // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".

  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */


function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options =
    /** @type {!Object} */
    keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path,
    /** @type {!Array} */
    keys);
  }

  if (isarray(path)) {
    return arrayToRegexp(
    /** @type {!Array} */
    path,
    /** @type {!Array} */
    keys, options);
  }

  return stringToRegexp(
  /** @type {string} */
  path,
  /** @type {!Array} */
  keys, options);
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;
/*  */
// $flow-disable-line

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  params = params || {};

  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = pathToRegexp_1.compile(path)); // Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}

    if (params.pathMatch) {
      params[0] = params.pathMatch;
    }

    return filler(params, {
      pretty: true
    });
  } catch (e) {
    if (true) {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }

    return '';
  } finally {
    // delete the 0 if it was added
    delete params[0];
  }
}
/*  */


function normalizeLocation(raw, current, append, router) {
  var next = typeof raw === 'string' ? {
    path: raw
  } : raw; // named target

  if (next._normalized) {
    return next;
  } else if (next.name) {
    return extend({}, raw);
  } // relative params


  if (!next.path && next.params && current) {
    next = extend({}, next);
    next._normalized = true;
    var params = extend(extend({}, current.params), next.params);

    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (true) {
      warn(false, "relative params navigation requires a current route.");
    }

    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;
  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);
  var hash = next.hash || parsedPath.hash;

  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}
/*  */
// work around weird flow bug


var toTypes = [String, Object];
var eventTypes = [String, Array];

var noop = function () {};

var Link = {
  name: 'RouterLink',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;
    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;
    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass; // Support global empty active class

    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;
    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;
    var compareTarget = route.redirectedFrom ? createRoute(null, normalizeLocation(route.redirectedFrom), null, router) : route;
    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location, noop);
        } else {
          router.push(location, noop);
        }
      }
    };

    var on = {
      click: guardEvent
    };

    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };
    var scopedSlot = !this.$scopedSlots.$hasNormal && this.$scopedSlots.default && this.$scopedSlots.default({
      href: href,
      route: route,
      navigate: handler,
      isActive: classes[activeClass],
      isExactActive: classes[exactActiveClass]
    });

    if (scopedSlot) {
      if (scopedSlot.length === 1) {
        return scopedSlot[0];
      } else if (scopedSlot.length > 1 || !scopedSlot.length) {
        if (true) {
          warn(false, "RouterLink with to=\"" + this.props.to + "\" is trying to use a scoped slot but it didn't provide exactly one child.");
        }

        return scopedSlot.length === 0 ? h() : h('span', {}, scopedSlot);
      }
    }

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = {
        href: href
      };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);

      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var aData = a.data = extend({}, a.data);
        aData.on = aData.on || {}; // transform existing events in both objects into arrays so we can push later

        for (var event in aData.on) {
          var handler$1 = aData.on[event];

          if (event in on) {
            aData.on[event] = Array.isArray(handler$1) ? handler$1 : [handler$1];
          }
        } // append new listeners for router-link


        for (var event$1 in on) {
          if (event$1 in aData.on) {
            // on[event] is always a function
            aData.on[event$1].push(on[event$1]);
          } else {
            aData.on[event$1] = handler;
          }
        }

        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {
    return;
  } // don't redirect when preventDefault called


  if (e.defaultPrevented) {
    return;
  } // don't redirect on right click


  if (e.button !== undefined && e.button !== 0) {
    return;
  } // don't redirect if `target="_blank"`


  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');

    if (/\b_blank\b/i.test(target)) {
      return;
    }
  } // this may be a Weex event which doesn't have this method


  if (e.preventDefault) {
    e.preventDefault();
  }

  return true;
}

function findAnchor(children) {
  if (children) {
    var child;

    for (var i = 0; i < children.length; i++) {
      child = children[i];

      if (child.tag === 'a') {
        return child;
      }

      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed && _Vue === Vue) {
    return;
  }

  install.installed = true;
  _Vue = Vue;

  var isDef = function (v) {
    return v !== undefined;
  };

  var registerInstance = function (vm, callVal) {
    var i = vm.$options._parentVnode;

    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;

        this._router.init(this);

        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = this.$parent && this.$parent._routerRoot || this;
      }

      registerInstance(this, this);
    },
    destroyed: function destroyed() {
      registerInstance(this);
    }
  });
  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this._routerRoot._router;
    }
  });
  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this._routerRoot._route;
    }
  });
  Vue.component('RouterView', View);
  Vue.component('RouterLink', Link);
  var strats = Vue.config.optionMergeStrategies; // use the same hook merging strategy for route hooks

  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}
/*  */


var inBrowser = typeof window !== 'undefined';
/*  */

function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || []; // $flow-disable-line

  var pathMap = oldPathMap || Object.create(null); // $flow-disable-line

  var nameMap = oldNameMap || Object.create(null);
  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  }); // ensure wildcard routes are always at the end

  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  if (true) {
    // warn if routes do not include leading slashes
    var found = pathList // check for missing leading slash
    .filter(function (path) {
      return path && path.charAt(0) !== '*' && path.charAt(0) !== '/';
    });

    if (found.length > 0) {
      var pathNames = found.map(function (path) {
        return "- " + path;
      }).join('\n');
      warn(false, "Non-nested routes must include a leading slash character. Fix the following routes: \n" + pathNames);
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;

  if (true) {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var pathToRegexpOptions = route.pathToRegexpOptions || {};
  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || {
      default: route.component
    },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : {
      default: route.props
    }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (true) {
      if (route.name && !route.redirect && route.children.some(function (child) {
        return /^\/?$/.test(child.path);
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }

    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];

    for (var i = 0; i < aliases.length; ++i) {
      var alias = aliases[i];

      if ( true && alias === path) {
        warn(false, "Found an alias with the same value as the path: \"" + path + "\". You have to remove that alias. It will be ignored in development."); // skip in dev to make it work

        continue;
      }

      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs
      );
    }
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if ( true && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function compileRouteRegex(path, pathToRegexpOptions) {
  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);

  if (true) {
    var keys = Object.create(null);
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], "Duplicate param keys in route with path: \"" + path + "\"");
      keys[key.name] = true;
    });
  }

  return regex;
}

function normalizePath(path, parent, strict) {
  if (!strict) {
    path = path.replace(/\/$/, '');
  }

  if (path[0] === '/') {
    return path;
  }

  if (parent == null) {
    return path;
  }

  return cleanPath(parent.path + "/" + path);
}
/*  */


function createMatcher(routes, router) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];

      if (true) {
        warn(record, "Route with name '" + name + "' does not exist");
      }

      if (!record) {
        return _createRoute(null, location);
      }

      var paramNames = record.regex.keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
      return _createRoute(record, location, redirectedFrom);
    } else if (location.path) {
      location.params = {};

      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];

        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom);
        }
      }
    } // no match


    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = {
        path: redirect
      };
    }

    if (!redirect || typeof redirect !== 'object') {
      if (true) {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }

      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];

      if (true) {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }

      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record); // 2. resolve params

      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\""); // 3. rematch with existing query and hash

      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      if (true) {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }

      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });

    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }

    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }

    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }

    return createRoute(record, location, redirectedFrom, router);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(regex, path, params) {
  var m = path.match(regex);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];

    if (key) {
      // Fix #1994: using * with props: true generates a param named 0
      params[key.name || 'pathMatch'] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}
/*  */
// use User Timing api (if present) for more accurate key precision


var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

function genStateKey() {
  return Time.now().toFixed(3);
}

var _key = genStateKey();

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  return _key = key;
}
/*  */


var positionStore = Object.create(null);

function setupScroll() {
  // Fix for #1585 for Firefox
  // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678
  // Fix for #2774 Support for apps loaded from Windows file shares not mapped to network drives: replaced location.origin with
  // window.location.protocol + '//' + window.location.host
  // location.host contains the port and location.hostname doesn't
  var protocolAndPath = window.location.protocol + '//' + window.location.host;
  var absolutePath = window.location.href.replace(protocolAndPath, '');
  window.history.replaceState({
    key: getStateKey()
  }, '', absolutePath);
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();

    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;

  if (!behavior) {
    return;
  }

  if (true) {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  } // wait until re-render finishes before scrolling


  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior.call(router, to, from, isPop ? position : null);

    if (!shouldScroll) {
      return;
    }

    if (typeof shouldScroll.then === 'function') {
      shouldScroll.then(function (shouldScroll) {
        scrollToPosition(shouldScroll, position);
      }).catch(function (err) {
        if (true) {
          assert(false, err.toString());
        }
      });
    } else {
      scrollToPosition(shouldScroll, position);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();

  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();

  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function normalizeOffset(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

var hashStartsWithNumberRE = /^#\d/;

function scrollToPosition(shouldScroll, position) {
  var isObject = typeof shouldScroll === 'object';

  if (isObject && typeof shouldScroll.selector === 'string') {
    // getElementById would still fail if the selector contains a more complicated query like #main[data-attr]
    // but at the same time, it doesn't make much sense to select an element with an id and an extra selector
    var el = hashStartsWithNumberRE.test(shouldScroll.selector) // $flow-disable-line
    ? document.getElementById(shouldScroll.selector.slice(1)) // $flow-disable-line
    : document.querySelector(shouldScroll.selector);

    if (el) {
      var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};
      offset = normalizeOffset(offset);
      position = getElementPosition(el, offset);
    } else if (isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }
  } else if (isObject && isValidPosition(shouldScroll)) {
    position = normalizePosition(shouldScroll);
  }

  if (position) {
    window.scrollTo(position.x, position.y);
  }
}
/*  */


var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}();

function pushState(url, replace) {
  saveScrollPosition(); // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls

  var history = window.history;

  try {
    if (replace) {
      history.replaceState({
        key: getStateKey()
      }, '', url);
    } else {
      history.pushState({
        key: setStateKey(genStateKey())
      }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}
/*  */


function runQueue(queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };

  step(0);
}
/*  */


function resolveAsyncComponents(matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;
    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;
        var resolve = once(function (resolvedDef) {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default;
          } // save resolved on async factory in case it's used elsewhere


          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;

          if (pending <= 0) {
            next();
          }
        });
        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
           true && warn(false, msg);

          if (!error) {
            error = isError(reason) ? reason : new Error(msg);
            next(error);
          }
        });
        var res;

        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }

        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;

            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) {
      next();
    }
  };
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

var hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

function isESModule(obj) {
  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';
} // in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.


function once(fn) {
  var called = false;
  return function () {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    if (called) {
      return;
    }

    called = true;
    return fn.apply(this, args);
  };
}

var NavigationDuplicated =
/*@__PURE__*/
function (Error) {
  function NavigationDuplicated(normalizedLocation) {
    Error.call(this);
    this.name = this._name = 'NavigationDuplicated'; // passing the message to super() doesn't seem to work in the transpiled version

    this.message = "Navigating to current location (\"" + normalizedLocation.fullPath + "\") is not allowed"; // add a stack property so services like Sentry can correctly display it

    Object.defineProperty(this, 'stack', {
      value: new Error().stack,
      writable: true,
      configurable: true
    }); // we could also have used
    // Error.captureStackTrace(this, this.constructor)
    // but it only exists on node and chrome
  }

  if (Error) NavigationDuplicated.__proto__ = Error;
  NavigationDuplicated.prototype = Object.create(Error && Error.prototype);
  NavigationDuplicated.prototype.constructor = NavigationDuplicated;
  return NavigationDuplicated;
}(Error); // support IE9


NavigationDuplicated._name = 'NavigationDuplicated';
/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base); // start with a route object that stands for "nowhere"

  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);

    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError(errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;
  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL(); // fire ready cbs once

    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }

    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) {
        cb(err);
      });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;
  var current = this.current;

  var abort = function (err) {
    // after merging https://github.com/vuejs/vue-router/pull/2771 we
    // When the user navigates through history through back/forward buttons
    // we do not want to throw the error. We only throw it if directly calling
    // push/replace. That's why it's not included in isError
    if (!isExtendedError(NavigationDuplicated, err) && isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }

    onAbort && onAbort(err);
  };

  if (isSameRoute(route, current) && // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort(new NavigationDuplicated(route));
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;
  var queue = [].concat( // in-component leave guards
  extractLeaveGuards(deactivated), // global before hooks
  this.router.beforeHooks, // in-component update hooks
  extractUpdateHooks(updated), // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }), // async components
  resolveAsyncComponents(activated));
  this.pending = route;

  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }

    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (typeof to === 'string' || typeof to === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();

          if (typeof to === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];

    var isValid = function () {
      return this$1.current === route;
    }; // wait until async components are resolved before
    // extracting in-component enter guards


    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }

      this$1.pending = null;
      onComplete(route);

      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/'; // strip full URL origin

      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  } // make sure there's the starting slash


  if (base.charAt(0) !== '/') {
    base = '/' + base;
  } // remove trailing slash


  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);

  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }

  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);

    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }

  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  if (instance) {
    return function boundRouteGuard() {
      return guard.apply(instance, arguments);
    };
  }
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }

      next(cb);
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key] && !instances[key]._isBeingDestroyed // do not reuse being destroyed instance
  ) {
      cb(instances[key]);
    } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}
/*  */


var HTML5History =
/*@__PURE__*/
function (History) {
  function HTML5History(router, base) {
    var this$1 = this;
    History.call(this, router, base);
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      setupScroll();
    }

    var initLocation = getLocation(this.base);
    window.addEventListener('popstate', function (e) {
      var current = this$1.current; // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.

      var location = getLocation(this$1.base);

      if (this$1.current === START && location === initLocation) {
        return;
      }

      this$1.transitionTo(location, function (route) {
        if (supportsScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if (History) HTML5History.__proto__ = History;
  HTML5History.prototype = Object.create(History && History.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = decodeURI(window.location.pathname);

  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }

  return (path || '/') + window.location.search + window.location.hash;
}
/*  */


var HashHistory =
/*@__PURE__*/
function (History) {
  function HashHistory(router, base, fallback) {
    History.call(this, router, base); // check history fallback deeplinking

    if (fallback && checkFallback(this.base)) {
      return;
    }

    ensureSlash();
  }

  if (History) HashHistory.__proto__ = History;
  HashHistory.prototype = Object.create(History && History.prototype);
  HashHistory.prototype.constructor = HashHistory; // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early

  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;
    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      setupScroll();
    }

    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {
      var current = this$1.current;

      if (!ensureSlash()) {
        return;
      }

      this$1.transitionTo(getHash(), function (route) {
        if (supportsScroll) {
          handleScroll(this$1.router, route, current, true);
        }

        if (!supportsPushState) {
          replaceHash(route.fullPath);
        }
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;

    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);

  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();

  if (path.charAt(0) === '/') {
    return true;
  }

  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#'); // empty path

  if (index < 0) {
    return '';
  }

  href = href.slice(index + 1); // decode the hash but not the search or hash
  // as search(query) is already decoded
  // https://github.com/vuejs/vue-router/issues/2708

  var searchIndex = href.indexOf('?');

  if (searchIndex < 0) {
    var hashIndex = href.indexOf('#');

    if (hashIndex > -1) {
      href = decodeURI(href.slice(0, hashIndex)) + href.slice(hashIndex);
    } else {
      href = decodeURI(href);
    }
  } else {
    if (searchIndex > -1) {
      href = decodeURI(href.slice(0, searchIndex)) + href.slice(searchIndex);
    }
  }

  return href;
}

function getUrl(path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  return base + "#" + path;
}

function pushHash(path) {
  if (supportsPushState) {
    pushState(getUrl(path));
  } else {
    window.location.hash = path;
  }
}

function replaceHash(path) {
  if (supportsPushState) {
    replaceState(getUrl(path));
  } else {
    window.location.replace(getUrl(path));
  }
}
/*  */


var AbstractHistory =
/*@__PURE__*/
function (History) {
  function AbstractHistory(router, base) {
    History.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History) AbstractHistory.__proto__ = History;
  AbstractHistory.prototype = Object.create(History && History.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;
    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;
    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;
    var targetIndex = this.index + n;

    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }

    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    }, function (err) {
      if (isExtendedError(NavigationDuplicated, err)) {
        this$1.index = targetIndex;
      }
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {// noop
  };

  return AbstractHistory;
}(History);
/*  */


var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};
  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);
  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;

  if (this.fallback) {
    mode = 'hash';
  }

  if (!inBrowser) {
    mode = 'abstract';
  }

  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;

    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;

    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;

    default:
      if (true) {
        assert(false, "invalid mode: " + mode);
      }

  }
};

var prototypeAccessors = {
  currentRoute: {
    configurable: true
  }
};

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app
/* Vue component instance */
) {
  var this$1 = this;
   true && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");
  this.apps.push(app); // set up app destroyed handler
  // https://github.com/vuejs/vue-router/issues/2639

  app.$once('hook:destroyed', function () {
    // clean out app from this.apps array once destroyed
    var index = this$1.apps.indexOf(app);

    if (index > -1) {
      this$1.apps.splice(index, 1);
    } // ensure we still have a main app or null if no apps
    // we do not release the router so it can be reused


    if (this$1.app === app) {
      this$1.app = this$1.apps[0] || null;
    }
  }); // main app previously initialized
  // return as we don't need to set up new history listener

  if (this.app) {
    return;
  }

  this.app = app;
  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };

    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  return registerHook(this.beforeHooks, fn);
};

VueRouter.prototype.beforeResolve = function beforeResolve(fn) {
  return registerHook(this.resolveHooks, fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  return registerHook(this.afterHooks, fn);
};

VueRouter.prototype.onReady = function onReady(cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError(errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  var this$1 = this; // $flow-disable-line

  if (!onComplete && !onAbort && typeof Promise !== 'undefined') {
    return new Promise(function (resolve, reject) {
      this$1.history.push(location, resolve, reject);
    });
  } else {
    this.history.push(location, onComplete, onAbort);
  }
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  var this$1 = this; // $flow-disable-line

  if (!onComplete && !onAbort && typeof Promise !== 'undefined') {
    return new Promise(function (resolve, reject) {
      this$1.history.replace(location, resolve, reject);
    });
  } else {
    this.history.replace(location, onComplete, onAbort);
  }
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;

  if (!route) {
    return [];
  }

  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  current = current || this.history.current;
  var location = normalizeLocation(to, current, append, this);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);

  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function registerHook(list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);

    if (i > -1) {
      list.splice(i, 1);
    }
  };
}

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '3.1.3';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

/* harmony default export */ __webpack_exports__["default"] = (VueRouter);

/***/ }),

/***/ "./node_modules/vue-style-loader/lib/addStylesClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/addStylesClient.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return addStylesClient; });
/* harmony import */ var _listToStyles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listToStyles */ "./node_modules/vue-style-loader/lib/listToStyles.js");
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = Object(_listToStyles__WEBPACK_IMPORTED_MODULE_0__["default"])(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = Object(_listToStyles__WEBPACK_IMPORTED_MODULE_0__["default"])(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "./node_modules/vue-style-loader/lib/listToStyles.js":
/*!***********************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/listToStyles.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return listToStyles; });
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };

    if (!newStyles[id]) {
      styles.push(newStyles[id] = {
        id: id,
        parts: [part]
      });
    } else {
      newStyles[id].parts.push(part);
    }
  }

  return styles;
}

/***/ }),

/***/ "./node_modules/vue/dist/vue.runtime.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.runtime.esm.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.6.11
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity = function (_) {
  return _;
};
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject(a);
  var isObjectB = isObject(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */

var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = '__proto__' in {}; // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set =
  /*@__PURE__*/
  function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check

var formatComponentName = noop;

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */


var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if ( true && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if ( true && customSetter) {
        customSetter();
      } // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if ( true && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
     true && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if ( true && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
     true && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */


function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       true && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
     true && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  if (true) {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : {
        type: val
      };
    }
  } else if (true) {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else if (true) {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];

      if (typeof def$$1 === 'function') {
        dirs[key] = {
          bind: def$$1,
          update: def$$1
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if ( true && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  if (true) {
    assertProp(prop, key, value, vm, absent);
  }

  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if ( true && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */


function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

function isExplicable(value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();

  try {
    if (vm) {
      var cur = vm;

      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;

        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;

              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }

    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      }); // issue #9511
      // avoid catch triggering multiple times when nested calls

      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  if (true) {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */


  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var isUsingMicroTask = false;
var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop);
    }
  };

  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };

  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */

/* not type checking this file because flow doesn't play well with Proxy */


var initProxy;

if (true) {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function (target, key) {
    warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */


var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag); // perf.clearMeasures(name)
    };
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;

  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
       true && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);

      if (true) {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }

      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if (true) {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658
    ) ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if ( true && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
       true && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);

        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       true && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
res, // the following are added in 2.6
hasDynamicKeys, contentHashKey) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  if (contentHashKey) {
    res.$key = contentHashKey;
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ( true && key !== '' && key !== null) {
      // null is a special value for explicitly removing a binding
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;

  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */

/*  */

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    if (true) {
      warn("Invalid Component definition: " + String(Ctor), context);
    }

    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
     true && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if ( true && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if ( true && isDef(data) && isDef(data.nativeOn)) {
        warn("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">.", context);
      }

      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }

  if (isObject(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  if (true) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {}
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if ( true && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if ( true && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  var owner = currentRenderingInstance;

  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null;
    owner.$on('hook:destroyed', function () {
      return remove(owners, owner);
    });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;

        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }

        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
       true && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;

              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;

            if (isUndef(factory.resolved)) {
              reject( true ? "timeout (" + res.timeout + "ms)" : undefined);
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;

    if (true) {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }

    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;

    if (true) {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if ( true && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (true) {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.


  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};

  if (true) {
    circular = {};
  }

  waiting = flushing = false;
} // Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.


var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)

if (inBrowser && !isIE) {
  var performance = window.performance;

  if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () {
      return performance.now();
    };
  }
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if ( true && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if ( true && !config.async) {
        flushSchedulerQueue();
        return;
      }

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$2 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$2; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true ? expOrFn.toString() : undefined; // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop;
       true && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    if (true) {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {} // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.


    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject(data)) {
    data = {};
     true && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];

    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
       true && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if ( true && getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }

  if ( true && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== 'function') {
        warn("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }

    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  if (true) {
    dataDef.set = function () {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }

  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
      }
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if ( true && config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    if (true) {
      initProxy(vm);
    } else {} // expose real self


    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if ( true && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}

function Vue(options) {
  if ( true && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if ( true && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if ( true && type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var cachedNode = cache[key];

    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];

  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  if (true) {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }

  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.11';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
       true && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps =
/*#__PURE__*/
Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }

      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if ( true && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;

    if (true) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (true) {
          checkDuplicateKeys(ch);
        }

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ( true && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ( true && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (true) {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};
/*  */

/*  */

/*  */

/*  */
// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.

var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.

function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.


var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;

    handler = original._wrapper = function (e) {
      if ( // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget || // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations
      // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
      // #9681 QtWebEngine event.timeStamp is negative value
      e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }

  target$1.addEventListener(name, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;

      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }

      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if ( // skip the update if old and new VDOM state is the same.
    // `value` is handled separately because the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This  #4521 by skipping the unnecesarry `checked` update.
    cur !== oldProps[key]) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};
/*  */

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def$$1 === 'object') {
    var res = {};

    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }

    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if ( true && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if ( true && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
     true && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if ( true && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if ( true && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update = this._update;

    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );

      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};
/*  */
// install platform specific utils

Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (true) {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }

    if ( true && config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
/*  */


/* harmony default export */ __webpack_exports__["default"] = (Vue);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./src/App.vue":
/*!*********************!*\
  !*** ./src/App.vue ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _App_vue_vue_type_template_id_7ba5bd90___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=template&id=7ba5bd90& */ "./src/App.vue?vue&type=template&id=7ba5bd90&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");

var script = {}


/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  script,
  _App_vue_vue_type_template_id_7ba5bd90___WEBPACK_IMPORTED_MODULE_0__["render"],
  _App_vue_vue_type_template_id_7ba5bd90___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/App.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/App.vue?vue&type=template&id=7ba5bd90&":
/*!****************************************************!*\
  !*** ./src/App.vue?vue&type=template&id=7ba5bd90& ***!
  \****************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_template_id_7ba5bd90___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../node_modules/vue-loader/lib??vue-loader-options!./App.vue?vue&type=template&id=7ba5bd90& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/App.vue?vue&type=template&id=7ba5bd90&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_template_id_7ba5bd90___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_template_id_7ba5bd90___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./src/assets/global.scss":
/*!********************************!*\
  !*** ./src/assets/global.scss ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./global.scss */ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/assets/global.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("da279faa", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");
/* harmony import */ var _App_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./App.vue */ "./src/App.vue");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./router */ "./src/router.js");
/* harmony import */ var _assets_global_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./assets/global.scss */ "./src/assets/global.scss");
/* harmony import */ var _assets_global_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_assets_global_scss__WEBPACK_IMPORTED_MODULE_4__);





new vue__WEBPACK_IMPORTED_MODULE_1__["default"]({
  router: _router__WEBPACK_IMPORTED_MODULE_3__["default"],
  render: function render(h) {
    return h(_App_vue__WEBPACK_IMPORTED_MODULE_2__["default"]);
  }
}).$mount("#app");

/***/ }),

/***/ "./src/router.js":
/*!***********************!*\
  !*** ./src/router.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.promise */ "./node_modules/core-js/modules/es.promise.js");
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");
/* harmony import */ var vue_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue-router */ "./node_modules/vue-router/dist/vue-router.esm.js");




vue__WEBPACK_IMPORTED_MODULE_2__["default"].use(vue_router__WEBPACK_IMPORTED_MODULE_3__["default"]);
var routes = [{
  path: "/",
  component: function component() {
    return Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(1), __webpack_require__.e(6)]).then(__webpack_require__.bind(null, /*! ./Form */ "./src/Form.vue"));
  }
}, {
  name: "complete",
  path: "/complete",
  component: function component() {
    return __webpack_require__.e(/*! import() */ 2).then(__webpack_require__.bind(null, /*! ./Complete */ "./src/Complete.vue"));
  }
}, {
  name: "error",
  path: "/error",
  component: function component() {
    return __webpack_require__.e(/*! import() */ 3).then(__webpack_require__.bind(null, /*! ./Error */ "./src/Error.vue"));
  }
}, {
  name: "test",
  path: "/test",
  component: function component() {
    return Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(1), __webpack_require__.e(7)]).then(__webpack_require__.bind(null, /*! ./Test */ "./src/Test.vue"));
  }
}];
/* harmony default export */ __webpack_exports__["default"] = (new vue_router__WEBPACK_IMPORTED_MODULE_3__["default"]({
  mode: "history",
  routes: routes
}));

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9iaW5kLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hvc3QtcmVwb3J0LWVycm9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1pb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9taWNyb3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1wcm9taXNlLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wZXJmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLXJlc29sdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2VyLWFnZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92OC12ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvZ2xvYmFsLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/NjQ3YSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUucnVudGltZS5lc20uanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT8yNjg1Iiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvZ2xvYmFsLnNjc3M/YzA5ZCIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcm91dGVyLmpzIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJpdCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIkNvbnN0cnVjdG9yIiwibmFtZSIsImlzT2JqZWN0IiwicmVxdWlyZSIsInRvSW5kZXhlZE9iamVjdCIsInRvTGVuZ3RoIiwidG9BYnNvbHV0ZUluZGV4IiwiY3JlYXRlTWV0aG9kIiwiSVNfSU5DTFVERVMiLCIkdGhpcyIsImVsIiwiZnJvbUluZGV4IiwiTyIsImxlbmd0aCIsImluZGV4IiwidmFsdWUiLCJpbmNsdWRlcyIsImluZGV4T2YiLCJhRnVuY3Rpb24iLCJmbiIsInRoYXQiLCJ1bmRlZmluZWQiLCJjYWxsIiwiYSIsImIiLCJjIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJhbk9iamVjdCIsIml0ZXJhdG9yIiwiRU5UUklFUyIsImVycm9yIiwicmV0dXJuTWV0aG9kIiwid2VsbEtub3duU3ltYm9sIiwiSVRFUkFUT1IiLCJTQUZFX0NMT1NJTkciLCJjYWxsZWQiLCJpdGVyYXRvcldpdGhSZXR1cm4iLCJuZXh0IiwiZG9uZSIsIkFycmF5IiwiZnJvbSIsImV4ZWMiLCJTS0lQX0NMT1NJTkciLCJJVEVSQVRJT05fU1VQUE9SVCIsIm9iamVjdCIsInRvU3RyaW5nIiwic2xpY2UiLCJUT19TVFJJTkdfVEFHX1NVUFBPUlQiLCJjbGFzc29mUmF3IiwiVE9fU1RSSU5HX1RBRyIsIkNPUlJFQ1RfQVJHVU1FTlRTIiwidHJ5R2V0Iiwia2V5IiwidGFnIiwicmVzdWx0IiwiT2JqZWN0IiwiY2FsbGVlIiwiaGFzIiwib3duS2V5cyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSIsImRlZmluZVByb3BlcnR5TW9kdWxlIiwidGFyZ2V0Iiwic291cmNlIiwia2V5cyIsImRlZmluZVByb3BlcnR5IiwiZiIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImkiLCJERVNDUklQVE9SUyIsImNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciIsImJpdG1hcCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImZhaWxzIiwiZ2V0IiwiZ2xvYmFsIiwiZG9jdW1lbnQiLCJFWElTVFMiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5IiwicmVkZWZpbmUiLCJzZXRHbG9iYWwiLCJjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzIiwiaXNGb3JjZWQiLCJvcHRpb25zIiwiVEFSR0VUIiwiR0xPQkFMIiwiU1RBVElDIiwic3RhdCIsIkZPUkNFRCIsInRhcmdldFByb3BlcnR5Iiwic291cmNlUHJvcGVydHkiLCJkZXNjcmlwdG9yIiwicHJvdG90eXBlIiwibm9UYXJnZXRHZXQiLCJmb3JjZWQiLCJzaGFtIiwicGF0aCIsInZhcmlhYmxlIiwibmFtZXNwYWNlIiwibWV0aG9kIiwiY2xhc3NvZiIsIkl0ZXJhdG9ycyIsImNoZWNrIiwiTWF0aCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJzZWxmIiwiRnVuY3Rpb24iLCJoYXNPd25Qcm9wZXJ0eSIsImNvbnNvbGUiLCJnZXRCdWlsdEluIiwic3BsaXQiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInN0b3JlIiwiZnVuY3Rpb25Ub1N0cmluZyIsImluc3BlY3RTb3VyY2UiLCJOQVRJVkVfV0VBS19NQVAiLCJvYmplY3RIYXMiLCJzaGFyZWRLZXkiLCJoaWRkZW5LZXlzIiwiV2Vha01hcCIsInNldCIsImVuZm9yY2UiLCJnZXR0ZXJGb3IiLCJUWVBFIiwic3RhdGUiLCJ0eXBlIiwid21nZXQiLCJ3bWhhcyIsIndtc2V0IiwibWV0YWRhdGEiLCJTVEFURSIsIkFycmF5UHJvdG90eXBlIiwicmVwbGFjZW1lbnQiLCJmZWF0dXJlIiwiZGV0ZWN0aW9uIiwiZGF0YSIsIm5vcm1hbGl6ZSIsIlBPTFlGSUxMIiwiTkFUSVZFIiwic3RyaW5nIiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwidXNlckFnZW50IiwidGVzdCIsImlzQXJyYXlJdGVyYXRvck1ldGhvZCIsImJpbmQiLCJnZXRJdGVyYXRvck1ldGhvZCIsImNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmciLCJSZXN1bHQiLCJzdG9wcGVkIiwiaXRlcmF0ZSIsIml0ZXJhYmxlIiwiQVNfRU5UUklFUyIsIklTX0lURVJBVE9SIiwiYm91bmRGdW5jdGlvbiIsIml0ZXJGbiIsInN0ZXAiLCJzdG9wIiwibWFjcm90YXNrIiwiSVNfSU9TIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJwcm9jZXNzIiwiUHJvbWlzZSIsIklTX05PREUiLCJxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IiLCJxdWV1ZU1pY3JvdGFzayIsImZsdXNoIiwiaGVhZCIsImxhc3QiLCJub3RpZnkiLCJ0b2dnbGUiLCJub2RlIiwicHJvbWlzZSIsInRoZW4iLCJwYXJlbnQiLCJkb21haW4iLCJleGl0IiwiZW50ZXIiLCJuZXh0VGljayIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJyZXNvbHZlIiwidGFzayIsImdldE93blByb3BlcnR5U3ltYm9scyIsIlN5bWJvbCIsIlByb21pc2VDYXBhYmlsaXR5IiwiQyIsInJlamVjdCIsIiQkcmVzb2x2ZSIsIiQkcmVqZWN0IiwiSUU4X0RPTV9ERUZJTkUiLCJ0b1ByaW1pdGl2ZSIsIm5hdGl2ZURlZmluZVByb3BlcnR5IiwiUCIsIkF0dHJpYnV0ZXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSIsIm5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImludGVybmFsT2JqZWN0S2V5cyIsImVudW1CdWdLZXlzIiwiY29uY2F0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm5hbWVzIiwicHVzaCIsIm5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlIiwiTkFTSE9STl9CVUciLCJWIiwiZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSIsImdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSIsIm5ld1Byb21pc2VDYXBhYmlsaXR5IiwieCIsImNvbnN0cnVjdG9yIiwicHJvbWlzZUNhcGFiaWxpdHkiLCJzcmMiLCJJbnRlcm5hbFN0YXRlTW9kdWxlIiwiZ2V0SW50ZXJuYWxTdGF0ZSIsImVuZm9yY2VJbnRlcm5hbFN0YXRlIiwiVEVNUExBVEUiLCJ1bnNhZmUiLCJzaW1wbGUiLCJqb2luIiwiU1BFQ0lFUyIsIkNPTlNUUlVDVE9SX05BTUUiLCJUQUciLCJzaGFyZWQiLCJ1aWQiLCJTSEFSRUQiLCJJU19QVVJFIiwidmVyc2lvbiIsIm1vZGUiLCJjb3B5cmlnaHQiLCJkZWZhdWx0Q29uc3RydWN0b3IiLCJTIiwiaHRtbCIsImxvY2F0aW9uIiwic2V0SW1tZWRpYXRlIiwiY2xlYXIiLCJjbGVhckltbWVkaWF0ZSIsIk1lc3NhZ2VDaGFubmVsIiwiRGlzcGF0Y2giLCJjb3VudGVyIiwicXVldWUiLCJPTlJFQURZU1RBVEVDSEFOR0UiLCJkZWZlciIsImNoYW5uZWwiLCJwb3J0IiwicnVuIiwiaWQiLCJydW5uZXIiLCJsaXN0ZW5lciIsImV2ZW50IiwicG9zdCIsInBvc3RNZXNzYWdlIiwicHJvdG9jb2wiLCJob3N0IiwiYXJncyIsIm5vdyIsInBvcnQyIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiaW1wb3J0U2NyaXB0cyIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJzZXRUaW1lb3V0IiwidG9JbnRlZ2VyIiwibWF4IiwibWluIiwiaW50ZWdlciIsIkluZGV4ZWRPYmplY3QiLCJyZXF1aXJlT2JqZWN0Q29lcmNpYmxlIiwiY2VpbCIsImZsb29yIiwiYXJndW1lbnQiLCJpc05hTiIsImlucHV0IiwiUFJFRkVSUkVEX1NUUklORyIsInZhbCIsInZhbHVlT2YiLCJwb3N0Zml4IiwicmFuZG9tIiwiTkFUSVZFX1NZTUJPTCIsInZlcnNpb25zIiwidjgiLCJtYXRjaCIsIlVTRV9TWU1CT0xfQVNfVUlEIiwiV2VsbEtub3duU3ltYm9sc1N0b3JlIiwiY3JlYXRlV2VsbEtub3duU3ltYm9sIiwid2l0aG91dFNldHRlciIsIiQiLCJOYXRpdmVQcm9taXNlIiwicmVkZWZpbmVBbGwiLCJzZXRUb1N0cmluZ1RhZyIsInNldFNwZWNpZXMiLCJhbkluc3RhbmNlIiwiY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uIiwic3BlY2llc0NvbnN0cnVjdG9yIiwibWljcm90YXNrIiwicHJvbWlzZVJlc29sdmUiLCJob3N0UmVwb3J0RXJyb3JzIiwibmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUiLCJwZXJmb3JtIiwiVjhfVkVSU0lPTiIsIlBST01JU0UiLCJzZXRJbnRlcm5hbFN0YXRlIiwiZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUiLCJQcm9taXNlQ29uc3RydWN0b3IiLCIkZmV0Y2giLCJuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkiLCJESVNQQVRDSF9FVkVOVCIsImNyZWF0ZUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIlVOSEFORExFRF9SRUpFQ1RJT04iLCJSRUpFQ1RJT05fSEFORExFRCIsIlBFTkRJTkciLCJGVUxGSUxMRUQiLCJSRUpFQ1RFRCIsIkhBTkRMRUQiLCJVTkhBTkRMRUQiLCJJbnRlcm5hbCIsIk93blByb21pc2VDYXBhYmlsaXR5IiwiUHJvbWlzZVdyYXBwZXIiLCJuYXRpdmVUaGVuIiwiR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSIsIlByb21pc2VSZWplY3Rpb25FdmVudCIsIkZha2VQcm9taXNlIiwiSU5DT1JSRUNUX0lURVJBVElPTiIsImFsbCIsImlzVGhlbmFibGUiLCJpc1JlamVjdCIsIm5vdGlmaWVkIiwiY2hhaW4iLCJyZWFjdGlvbnMiLCJvayIsInJlYWN0aW9uIiwiaGFuZGxlciIsImZhaWwiLCJleGl0ZWQiLCJyZWplY3Rpb24iLCJvbkhhbmRsZVVuaGFuZGxlZCIsIm9uVW5oYW5kbGVkIiwicmVhc29uIiwiaW5pdEV2ZW50IiwiSVNfVU5IQU5ETEVEIiwiaXNVbmhhbmRsZWQiLCJlbWl0IiwidW53cmFwIiwiaW50ZXJuYWxSZWplY3QiLCJpbnRlcm5hbFJlc29sdmUiLCJ3cmFwcGVyIiwiZXhlY3V0b3IiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJmZXRjaCIsIndyYXAiLCJyIiwiY2FwYWJpbGl0eSIsIiRwcm9taXNlUmVzb2x2ZSIsInZhbHVlcyIsInJlbWFpbmluZyIsImFscmVhZHlDYWxsZWQiLCJyYWNlIiwidXNlU291cmNlTWFwIiwibGlzdCIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiY3NzTWFwcGluZyIsImJ0b2EiLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZXMiLCJzb3VyY2VSb290Iiwic291cmNlTWFwIiwiYmFzZTY0IiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwiSXRlbSIsImFycmF5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwicnVudGltZSIsIk9wIiwiaGFzT3duIiwiJFN5bWJvbCIsIml0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsInRvU3RyaW5nVGFnIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJ0cnlMb2NzTGlzdCIsInByb3RvR2VuZXJhdG9yIiwiR2VuZXJhdG9yIiwiZ2VuZXJhdG9yIiwiY3JlYXRlIiwiY29udGV4dCIsIkNvbnRleHQiLCJfaW52b2tlIiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwib2JqIiwiYXJnIiwiZXJyIiwiR2VuU3RhdGVTdXNwZW5kZWRTdGFydCIsIkdlblN0YXRlU3VzcGVuZGVkWWllbGQiLCJHZW5TdGF0ZUV4ZWN1dGluZyIsIkdlblN0YXRlQ29tcGxldGVkIiwiQ29udGludWVTZW50aW5lbCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJJdGVyYXRvclByb3RvdHlwZSIsImdldFByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJOYXRpdmVJdGVyYXRvclByb3RvdHlwZSIsIkdwIiwiZGlzcGxheU5hbWUiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJmb3JFYWNoIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsImN0b3IiLCJtYXJrIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJhd3JhcCIsIl9fYXdhaXQiLCJBc3luY0l0ZXJhdG9yIiwiaW52b2tlIiwicmVjb3JkIiwidW53cmFwcGVkIiwicHJldmlvdXNQcm9taXNlIiwiZW5xdWV1ZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwiYXN5bmMiLCJpdGVyIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJpbmZvIiwicmVzdWx0TmFtZSIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwiZW50cnkiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwicmV2ZXJzZSIsInBvcCIsIml0ZXJhdG9yTWV0aG9kIiwic2tpcFRlbXBSZXNldCIsInByZXYiLCJjaGFyQXQiLCJyb290RW50cnkiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsInJlZ2VuZXJhdG9yUnVudGltZSIsImFjY2lkZW50YWxTdHJpY3RNb2RlIiwibmV4dEhhbmRsZSIsInRhc2tzQnlIYW5kbGUiLCJjdXJyZW50bHlSdW5uaW5nQVRhc2siLCJkb2MiLCJyZWdpc3RlckltbWVkaWF0ZSIsImNhbGxiYWNrIiwicnVuSWZQcmVzZW50IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJvbkdsb2JhbE1lc3NhZ2UiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImRvY3VtZW50RWxlbWVudCIsInNjcmlwdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsInNjb3BlIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsb3NlIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJyZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsIndhcm4iLCJpc0Vycm9yIiwiaXNFeHRlbmRlZEVycm9yIiwiX25hbWUiLCJleHRlbmQiLCJWaWV3IiwiZnVuY3Rpb25hbCIsInByb3BzIiwiZGVmYXVsdCIsInJlbmRlciIsIl8iLCJjaGlsZHJlbiIsInJvdXRlclZpZXciLCJoIiwiJGNyZWF0ZUVsZW1lbnQiLCJyb3V0ZSIsIiRyb3V0ZSIsImNhY2hlIiwiX3JvdXRlclZpZXdDYWNoZSIsImRlcHRoIiwiaW5hY3RpdmUiLCJfcm91dGVyUm9vdCIsInZub2RlRGF0YSIsIiR2bm9kZSIsImtlZXBBbGl2ZSIsIl9pbmFjdGl2ZSIsIiRwYXJlbnQiLCJyb3V0ZXJWaWV3RGVwdGgiLCJtYXRjaGVkIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInJlZ2lzdGVyUm91dGVJbnN0YW5jZSIsInZtIiwiY3VycmVudCIsImluc3RhbmNlcyIsImhvb2siLCJwcmVwYXRjaCIsInZub2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJpbml0IiwicHJvcHNUb1Bhc3MiLCJyZXNvbHZlUHJvcHMiLCJhdHRycyIsImNvbmZpZyIsInBhcmFtcyIsImVuY29kZVJlc2VydmVSRSIsImVuY29kZVJlc2VydmVSZXBsYWNlciIsImNoYXJDb2RlQXQiLCJjb21tYVJFIiwiZW5jb2RlIiwic3RyIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVzb2x2ZVF1ZXJ5IiwicXVlcnkiLCJleHRyYVF1ZXJ5IiwiX3BhcnNlUXVlcnkiLCJwYXJzZSIsInBhcnNlUXVlcnkiLCJwYXJzZWRRdWVyeSIsInJlcyIsInRyaW0iLCJwYXJhbSIsInBhcnRzIiwic2hpZnQiLCJpc0FycmF5Iiwic3RyaW5naWZ5UXVlcnkiLCJ2YWwyIiwiZmlsdGVyIiwidHJhaWxpbmdTbGFzaFJFIiwiY3JlYXRlUm91dGUiLCJyZWRpcmVjdGVkRnJvbSIsInJvdXRlciIsImNsb25lIiwibWV0YSIsImhhc2giLCJmdWxsUGF0aCIsImdldEZ1bGxQYXRoIiwiZm9ybWF0TWF0Y2giLCJmcmVlemUiLCJTVEFSVCIsInVuc2hpZnQiLCJfc3RyaW5naWZ5UXVlcnkiLCJpc1NhbWVSb3V0ZSIsImlzT2JqZWN0RXF1YWwiLCJhS2V5cyIsImJLZXlzIiwiZXZlcnkiLCJhVmFsIiwiYlZhbCIsImlzSW5jbHVkZWRSb3V0ZSIsInF1ZXJ5SW5jbHVkZXMiLCJyZXNvbHZlUGF0aCIsInJlbGF0aXZlIiwiYmFzZSIsImFwcGVuZCIsImZpcnN0Q2hhciIsInN0YWNrIiwic2VnbWVudHMiLCJzZWdtZW50IiwicGFyc2VQYXRoIiwiaGFzaEluZGV4IiwicXVlcnlJbmRleCIsImNsZWFuUGF0aCIsImlzYXJyYXkiLCJhcnIiLCJwYXRoVG9SZWdleHBfMSIsInBhdGhUb1JlZ2V4cCIsInBhcnNlXzEiLCJjb21waWxlXzEiLCJjb21waWxlIiwidG9rZW5zVG9GdW5jdGlvbl8xIiwidG9rZW5zVG9GdW5jdGlvbiIsInRva2Vuc1RvUmVnRXhwXzEiLCJ0b2tlbnNUb1JlZ0V4cCIsIlBBVEhfUkVHRVhQIiwiUmVnRXhwIiwidG9rZW5zIiwiZGVmYXVsdERlbGltaXRlciIsImRlbGltaXRlciIsIm0iLCJlc2NhcGVkIiwib2Zmc2V0IiwicHJlZml4IiwiY2FwdHVyZSIsImdyb3VwIiwibW9kaWZpZXIiLCJhc3RlcmlzayIsInBhcnRpYWwiLCJyZXBlYXQiLCJvcHRpb25hbCIsInBhdHRlcm4iLCJlc2NhcGVHcm91cCIsImVzY2FwZVN0cmluZyIsInN1YnN0ciIsImVuY29kZVVSSUNvbXBvbmVudFByZXR0eSIsImVuY29kZVVSSSIsInRvVXBwZXJDYXNlIiwiZW5jb2RlQXN0ZXJpc2siLCJtYXRjaGVzIiwib3B0cyIsInByZXR0eSIsInRva2VuIiwiaiIsImF0dGFjaEtleXMiLCJyZSIsImZsYWdzIiwic2Vuc2l0aXZlIiwicmVnZXhwVG9SZWdleHAiLCJncm91cHMiLCJhcnJheVRvUmVnZXhwIiwicmVnZXhwIiwic3RyaW5nVG9SZWdleHAiLCJzdHJpY3QiLCJlbmQiLCJlbmRzV2l0aERlbGltaXRlciIsInJlZ2V4cENvbXBpbGVDYWNoZSIsImZpbGxQYXJhbXMiLCJyb3V0ZU1zZyIsImZpbGxlciIsInBhdGhNYXRjaCIsIm5vcm1hbGl6ZUxvY2F0aW9uIiwicmF3IiwiX25vcm1hbGl6ZWQiLCJyYXdQYXRoIiwicGFyc2VkUGF0aCIsImJhc2VQYXRoIiwidG9UeXBlcyIsImV2ZW50VHlwZXMiLCJMaW5rIiwidG8iLCJyZXF1aXJlZCIsImV4YWN0IiwiQm9vbGVhbiIsImFjdGl2ZUNsYXNzIiwiZXhhY3RBY3RpdmVDbGFzcyIsInRoaXMkMSIsIiRyb3V0ZXIiLCJocmVmIiwiY2xhc3NlcyIsImdsb2JhbEFjdGl2ZUNsYXNzIiwibGlua0FjdGl2ZUNsYXNzIiwiZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyIsImxpbmtFeGFjdEFjdGl2ZUNsYXNzIiwiYWN0aXZlQ2xhc3NGYWxsYmFjayIsImV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayIsImNvbXBhcmVUYXJnZXQiLCJndWFyZEV2ZW50IiwiY2xpY2siLCJjbGFzcyIsInNjb3BlZFNsb3QiLCIkc2NvcGVkU2xvdHMiLCIkaGFzTm9ybWFsIiwibmF2aWdhdGUiLCJpc0FjdGl2ZSIsImlzRXhhY3RBY3RpdmUiLCJmaW5kQW5jaG9yIiwiJHNsb3RzIiwiaXNTdGF0aWMiLCJhRGF0YSIsImhhbmRsZXIkMSIsImV2ZW50JDEiLCJhQXR0cnMiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiZGVmYXVsdFByZXZlbnRlZCIsImJ1dHRvbiIsImN1cnJlbnRUYXJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJwcmV2ZW50RGVmYXVsdCIsImNoaWxkIiwiX1Z1ZSIsImluc3RhbGwiLCJWdWUiLCJpbnN0YWxsZWQiLCJpc0RlZiIsInYiLCJyZWdpc3Rlckluc3RhbmNlIiwiY2FsbFZhbCIsIiRvcHRpb25zIiwiX3BhcmVudFZub2RlIiwibWl4aW4iLCJiZWZvcmVDcmVhdGUiLCJfcm91dGVyIiwidXRpbCIsImRlZmluZVJlYWN0aXZlIiwiaGlzdG9yeSIsImRlc3Ryb3llZCIsIl9yb3V0ZSIsInN0cmF0cyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsImJlZm9yZVJvdXRlRW50ZXIiLCJiZWZvcmVSb3V0ZUxlYXZlIiwiYmVmb3JlUm91dGVVcGRhdGUiLCJjcmVhdGVkIiwiaW5Ccm93c2VyIiwiY3JlYXRlUm91dGVNYXAiLCJyb3V0ZXMiLCJvbGRQYXRoTGlzdCIsIm9sZFBhdGhNYXAiLCJvbGROYW1lTWFwIiwicGF0aExpc3QiLCJwYXRoTWFwIiwibmFtZU1hcCIsImFkZFJvdXRlUmVjb3JkIiwibCIsInNwbGljZSIsImZvdW5kIiwicGF0aE5hbWVzIiwibWF0Y2hBcyIsInBhdGhUb1JlZ2V4cE9wdGlvbnMiLCJub3JtYWxpemVkUGF0aCIsIm5vcm1hbGl6ZVBhdGgiLCJjYXNlU2Vuc2l0aXZlIiwicmVnZXgiLCJjb21waWxlUm91dGVSZWdleCIsInJlZGlyZWN0IiwiYmVmb3JlRW50ZXIiLCJzb21lIiwiY2hpbGRNYXRjaEFzIiwiYWxpYXMiLCJhbGlhc2VzIiwiYWxpYXNSb3V0ZSIsImNyZWF0ZU1hdGNoZXIiLCJhZGRSb3V0ZXMiLCJjdXJyZW50Um91dGUiLCJfY3JlYXRlUm91dGUiLCJwYXJhbU5hbWVzIiwicmVjb3JkJDEiLCJtYXRjaFJvdXRlIiwib3JpZ2luYWxSZWRpcmVjdCIsInRhcmdldFJlY29yZCIsInJlc29sdmVSZWNvcmRQYXRoIiwicmVzb2x2ZWRQYXRoIiwiYWxpYXNlZFBhdGgiLCJhbGlhc2VkTWF0Y2giLCJhbGlhc2VkUmVjb3JkIiwiVGltZSIsInBlcmZvcm1hbmNlIiwiRGF0ZSIsImdlblN0YXRlS2V5IiwidG9GaXhlZCIsIl9rZXkiLCJnZXRTdGF0ZUtleSIsInNldFN0YXRlS2V5IiwicG9zaXRpb25TdG9yZSIsInNldHVwU2Nyb2xsIiwicHJvdG9jb2xBbmRQYXRoIiwiYWJzb2x1dGVQYXRoIiwicmVwbGFjZVN0YXRlIiwic2F2ZVNjcm9sbFBvc2l0aW9uIiwiaGFuZGxlU2Nyb2xsIiwiaXNQb3AiLCJhcHAiLCJiZWhhdmlvciIsInNjcm9sbEJlaGF2aW9yIiwiJG5leHRUaWNrIiwicG9zaXRpb24iLCJnZXRTY3JvbGxQb3NpdGlvbiIsInNob3VsZFNjcm9sbCIsInNjcm9sbFRvUG9zaXRpb24iLCJjYXRjaCIsInBhZ2VYT2Zmc2V0IiwieSIsInBhZ2VZT2Zmc2V0IiwiZ2V0RWxlbWVudFBvc2l0aW9uIiwiZG9jRWwiLCJkb2NSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZWxSZWN0IiwibGVmdCIsInRvcCIsImlzVmFsaWRQb3NpdGlvbiIsImlzTnVtYmVyIiwibm9ybWFsaXplUG9zaXRpb24iLCJub3JtYWxpemVPZmZzZXQiLCJoYXNoU3RhcnRzV2l0aE51bWJlclJFIiwic2VsZWN0b3IiLCJnZXRFbGVtZW50QnlJZCIsInF1ZXJ5U2VsZWN0b3IiLCJzY3JvbGxUbyIsInN1cHBvcnRzUHVzaFN0YXRlIiwidWEiLCJuYXZpZ2F0b3IiLCJwdXNoU3RhdGUiLCJ1cmwiLCJydW5RdWV1ZSIsImNiIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50cyIsImhhc0FzeW5jIiwicGVuZGluZyIsImZsYXRNYXBDb21wb25lbnRzIiwiZGVmIiwiY2lkIiwicmVzb2x2ZWREZWYiLCJpc0VTTW9kdWxlIiwicmVzb2x2ZWQiLCJtc2ciLCJjb21wIiwiZmxhdHRlbiIsImhhc1N5bWJvbCIsIl9fZXNNb2R1bGUiLCJOYXZpZ2F0aW9uRHVwbGljYXRlZCIsIm5vcm1hbGl6ZWRMb2NhdGlvbiIsIkhpc3RvcnkiLCJub3JtYWxpemVCYXNlIiwicmVhZHkiLCJyZWFkeUNicyIsInJlYWR5RXJyb3JDYnMiLCJlcnJvckNicyIsImxpc3RlbiIsIm9uUmVhZHkiLCJlcnJvckNiIiwib25FcnJvciIsInRyYW5zaXRpb25UbyIsIm9uQ29tcGxldGUiLCJvbkFib3J0IiwiY29uZmlybVRyYW5zaXRpb24iLCJ1cGRhdGVSb3V0ZSIsImVuc3VyZVVSTCIsImFib3J0IiwicmVzb2x2ZVF1ZXVlIiwidXBkYXRlZCIsImRlYWN0aXZhdGVkIiwiYWN0aXZhdGVkIiwiZXh0cmFjdExlYXZlR3VhcmRzIiwiYmVmb3JlSG9va3MiLCJleHRyYWN0VXBkYXRlSG9va3MiLCJwb3N0RW50ZXJDYnMiLCJpc1ZhbGlkIiwiZW50ZXJHdWFyZHMiLCJleHRyYWN0RW50ZXJHdWFyZHMiLCJyZXNvbHZlSG9va3MiLCJhZnRlckhvb2tzIiwiYmFzZUVsIiwiZXh0cmFjdEd1YXJkcyIsInJlY29yZHMiLCJndWFyZHMiLCJpbnN0YW5jZSIsImd1YXJkIiwiZXh0cmFjdEd1YXJkIiwiYmluZEd1YXJkIiwiYm91bmRSb3V0ZUd1YXJkIiwiY2JzIiwiYmluZEVudGVyR3VhcmQiLCJyb3V0ZUVudGVyR3VhcmQiLCJwb2xsIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJIVE1MNUhpc3RvcnkiLCJleHBlY3RTY3JvbGwiLCJzdXBwb3J0c1Njcm9sbCIsImluaXRMb2NhdGlvbiIsImdldExvY2F0aW9uIiwiZ28iLCJuIiwiZnJvbVJvdXRlIiwiZ2V0Q3VycmVudExvY2F0aW9uIiwiZGVjb2RlVVJJIiwicGF0aG5hbWUiLCJzZWFyY2giLCJIYXNoSGlzdG9yeSIsImZhbGxiYWNrIiwiY2hlY2tGYWxsYmFjayIsImVuc3VyZVNsYXNoIiwic2V0dXBMaXN0ZW5lcnMiLCJnZXRIYXNoIiwicmVwbGFjZUhhc2giLCJwdXNoSGFzaCIsInNlYXJjaEluZGV4IiwiZ2V0VXJsIiwiQWJzdHJhY3RIaXN0b3J5IiwidGFyZ2V0SW5kZXgiLCJWdWVSb3V0ZXIiLCJhcHBzIiwibWF0Y2hlciIsInByb3RvdHlwZUFjY2Vzc29ycyIsIiRvbmNlIiwic2V0dXBIYXNoTGlzdGVuZXIiLCJiZWZvcmVFYWNoIiwicmVnaXN0ZXJIb29rIiwiYmVmb3JlUmVzb2x2ZSIsImFmdGVyRWFjaCIsImJhY2siLCJmb3J3YXJkIiwiZ2V0TWF0Y2hlZENvbXBvbmVudHMiLCJjcmVhdGVIcmVmIiwibm9ybWFsaXplZFRvIiwiZGVmaW5lUHJvcGVydGllcyIsInVzZSIsImxpc3RUb1N0eWxlcyIsInBhcmVudElkIiwic3R5bGVzIiwibmV3U3R5bGVzIiwiY3NzIiwibWVkaWEiLCJwYXJ0IiwiZW1wdHlPYmplY3QiLCJpc1VuZGVmIiwiaXNUcnVlIiwiaXNGYWxzZSIsImlzUHJpbWl0aXZlIiwiX3RvU3RyaW5nIiwidG9SYXdUeXBlIiwiaXNQbGFpbk9iamVjdCIsImlzUmVnRXhwIiwiaXNWYWxpZEFycmF5SW5kZXgiLCJwYXJzZUZsb2F0IiwiaXNGaW5pdGUiLCJpc1Byb21pc2UiLCJ0b051bWJlciIsIm1ha2VNYXAiLCJleHBlY3RzTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImNhY2hlZCIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwiY2FwaXRhbGl6ZSIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiY3R4IiwiYm91bmRGbiIsIl9sZW5ndGgiLCJuYXRpdmVCaW5kIiwidG9BcnJheSIsInN0YXJ0IiwicmV0IiwiX2Zyb20iLCJ0b09iamVjdCIsIm5vIiwiaWRlbnRpdHkiLCJsb29zZUVxdWFsIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiaXNBcnJheUEiLCJpc0FycmF5QiIsImdldFRpbWUiLCJrZXlzQSIsImtleXNCIiwibG9vc2VJbmRleE9mIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsImVycm9ySGFuZGxlciIsIndhcm5IYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsIl9saWZlY3ljbGVIb29rcyIsInVuaWNvZGVSZWdFeHAiLCJpc1Jlc2VydmVkIiwiYmFpbFJFIiwiaGFzUHJvdG8iLCJpbldlZXgiLCJXWEVudmlyb25tZW50IiwicGxhdGZvcm0iLCJ3ZWV4UGxhdGZvcm0iLCJVQSIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJpc1BoYW50b21KUyIsImlzRkYiLCJuYXRpdmVXYXRjaCIsIndhdGNoIiwic3VwcG9ydHNQYXNzaXZlIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsIlJlZmxlY3QiLCJfU2V0IiwiU2V0IiwiYWRkIiwidGlwIiwiZ2VuZXJhdGVDb21wb25lbnRUcmFjZSIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwidHJhY2UiLCJpbmNsdWRlRmlsZSIsIiRyb290IiwiX2lzVnVlIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwiRGVwIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsImFkZERlcCIsInNvcnQiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJwb3BUYXJnZXQiLCJWTm9kZSIsInRleHQiLCJlbG0iLCJjb21wb25lbnRPcHRpb25zIiwiYXN5bmNGYWN0b3J5IiwibnMiLCJmbkNvbnRleHQiLCJmbk9wdGlvbnMiLCJmblNjb3BlSWQiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwiY2xvbmVkIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsIm1ldGhvZHNUb1BhdGNoIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIml0ZW1zIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJwcm9wZXJ0eSIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJkZWwiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJ0b1ZhbCIsImZyb21WYWwiLCJtZXJnZURhdGFPckZuIiwicGFyZW50VmFsIiwiY2hpbGRWYWwiLCJtZXJnZWREYXRhRm4iLCJtZXJnZWRJbnN0YW5jZURhdGFGbiIsImluc3RhbmNlRGF0YSIsImRlZmF1bHREYXRhIiwibWVyZ2VIb29rIiwiZGVkdXBlSG9va3MiLCJob29rcyIsIm1lcmdlQXNzZXRzIiwiYXNzZXJ0T2JqZWN0VHlwZSIsImtleSQxIiwibWV0aG9kcyIsImluamVjdCIsImNvbXB1dGVkIiwicHJvdmlkZSIsImNoZWNrQ29tcG9uZW50cyIsInZhbGlkYXRlQ29tcG9uZW50TmFtZSIsIm5vcm1hbGl6ZVByb3BzIiwibm9ybWFsaXplSW5qZWN0Iiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsImRlZiQkMSIsIm1lcmdlT3B0aW9ucyIsIl9iYXNlIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3AiLCJhYnNlbnQiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJzdHJpbmdJbmRleCIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkT2JzZXJ2ZSIsImFzc2VydFByb3AiLCJfcHJvcHMiLCJnZXRUeXBlIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsImdldEludmFsaWRUeXBlTWVzc2FnZSIsInZhbGlkYXRvciIsInNpbXBsZUNoZWNrUkUiLCJ0IiwiaXNTYW1lVHlwZSIsInJlY2VpdmVkVHlwZSIsImV4cGVjdGVkVmFsdWUiLCJzdHlsZVZhbHVlIiwicmVjZWl2ZWRWYWx1ZSIsImlzRXhwbGljYWJsZSIsImlzQm9vbGVhbiIsIk51bWJlciIsImV4cGxpY2l0VHlwZXMiLCJlbGVtIiwiaGFuZGxlRXJyb3IiLCJjdXIiLCJlcnJvckNhcHR1cmVkIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJpbnZva2VXaXRoRXJyb3JIYW5kbGluZyIsIl9oYW5kbGVkIiwibG9nRXJyb3IiLCJpc1VzaW5nTWljcm9UYXNrIiwiY2FsbGJhY2tzIiwiZmx1c2hDYWxsYmFja3MiLCJjb3BpZXMiLCJ0aW1lckZ1bmMiLCJwIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsIl9yZXNvbHZlIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsIndhcm5SZXNlcnZlZFByZWZpeCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCIkZGF0YSIsImdldEhhbmRsZXIiLCJoYW5kbGVycyIsIl93aXRoU3RyaXBwZWQiLCJfcmVuZGVyUHJveHkiLCJzZWVuT2JqZWN0cyIsInRyYXZlcnNlIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImlzRnJvemVuIiwiZGVwSWQiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY3JlYXRlRm5JbnZva2VyIiwiZm5zIiwiaW52b2tlciIsImFyZ3VtZW50cyQxIiwidXBkYXRlTGlzdGVuZXJzIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjcmVhdGVPbmNlSGFuZGxlciIsIm9sZCIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsImV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsInByZXNlcnZlIiwic2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4iLCJpc1RleHROb2RlIiwibmVzdGVkSW5kZXgiLCJsYXN0SW5kZXgiLCJfaXNWTGlzdCIsImluaXRQcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwicHJvdmlkZUtleSIsInByb3ZpZGVEZWZhdWx0IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwibmFtZSQxIiwiaXNXaGl0ZXNwYWNlIiwibm9ybWFsaXplU2NvcGVkU2xvdHMiLCJub3JtYWxTbG90cyIsInByZXZTbG90cyIsImhhc05vcm1hbFNsb3RzIiwiaXNTdGFibGUiLCIkc3RhYmxlIiwiJGtleSIsIm5vcm1hbGl6ZVNjb3BlZFNsb3QiLCJrZXkkMiIsInByb3h5Tm9ybWFsU2xvdCIsInByb3h5IiwicmVuZGVyTGlzdCIsInJlbmRlclNsb3QiLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwibm9kZXMiLCJyZXNvbHZlRmlsdGVyIiwiaXNLZXlOb3RNYXRjaCIsImV4cGVjdCIsImFjdHVhbCIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluS2V5Q29kZSIsImV2ZW50S2V5TmFtZSIsImJ1aWx0SW5LZXlOYW1lIiwibWFwcGVkS2V5Q29kZSIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImlzU3luYyIsImxvb3AiLCJkb21Qcm9wcyIsImNhbWVsaXplZEtleSIsImh5cGhlbmF0ZWRLZXkiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiaGFzRHluYW1pY0tleXMiLCJjb250ZW50SGFzaEtleSIsImJpbmREeW5hbWljS2V5cyIsImJhc2VPYmoiLCJwcmVwZW5kTW9kaWZpZXIiLCJzeW1ib2wiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIl9kIiwiX3AiLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsImNvbnRleHRWbSIsIl9vcmlnaW5hbCIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsImluamVjdGlvbnMiLCJzY29wZWRTbG90cyIsIl9zY29wZUlkIiwiX2MiLCJkIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJyZW5kZXJDb250ZXh0IiwiY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCIsInZub2RlcyIsImRldnRvb2xzTWV0YSIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJoeWRyYXRpbmciLCJfaXNEZXN0cm95ZWQiLCJtb3VudGVkTm9kZSIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCJhY3RpdmVJbnN0YW5jZSIsIiRtb3VudCIsIm9sZFZub2RlIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJpbnNlcnQiLCJfaXNNb3VudGVkIiwiY2FsbEhvb2siLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkZXN0cm95IiwiJGRlc3Ryb3kiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJiYXNlQ3RvciIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsIm5hdGl2ZU9uIiwiYWJzdHJhY3QiLCJpbnN0YWxsQ29tcG9uZW50SG9va3MiLCJfaXNDb21wb25lbnQiLCJpbmxpbmVUZW1wbGF0ZSIsInRvTWVyZ2UiLCJfbWVyZ2VkIiwibWVyZ2VIb29rJDEiLCJmMSIsImYyIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwiaXMiLCJwcmUiLCJhcHBseU5TIiwicmVnaXN0ZXJEZWVwQmluZGluZ3MiLCJmb3JjZSIsInN0eWxlIiwiaW5pdFJlbmRlciIsIl92bm9kZSIsInBhcmVudFZub2RlIiwiX3JlbmRlckNoaWxkcmVuIiwicGFyZW50RGF0YSIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UiLCJyZW5kZXJNaXhpbiIsIl9yZW5kZXIiLCJyZW5kZXJFcnJvciIsImVuc3VyZUN0b3IiLCJmYWN0b3J5IiwiZXJyb3JDb21wIiwib3duZXIiLCJvd25lcnMiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJzeW5jIiwidGltZXJMb2FkaW5nIiwidGltZXJUaW1lb3V0IiwiJG9uIiwiZm9yY2VSZW5kZXIiLCJyZW5kZXJDb21wbGV0ZWQiLCIkZm9yY2VVcGRhdGUiLCJkZWxheSIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCJyZW1vdmUkMSIsIiRvZmYiLCJfdGFyZ2V0Iiwib25jZUhhbmRsZXIiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsImhvb2tSRSIsImkkMSIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJzZXRBY3RpdmVJbnN0YW5jZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsImluaXRMaWZlY3ljbGUiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2RpcmVjdEluYWN0aXZlIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwicmVzdG9yZUFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX192dWVfXyIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX3VpZCIsIldhdGNoZXIiLCJiZWZvcmUiLCJyZW5kZXJDaGlsZHJlbiIsIm5ld1Njb3BlZFNsb3RzIiwib2xkU2NvcGVkU2xvdHMiLCJoYXNEeW5hbWljU2NvcGVkU2xvdCIsIm5lZWRzRm9yY2VVcGRhdGUiLCIkYXR0cnMiLCIkbGlzdGVuZXJzIiwicHJvcEtleXMiLCJfcHJvcEtleXMiLCJpc0luSW5hY3RpdmVUcmVlIiwiZGlyZWN0IiwiTUFYX1VQREFURV9DT1VOVCIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiY3VycmVudEZsdXNoVGltZXN0YW1wIiwiZ2V0Tm93IiwidGltZVN0YW1wIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJ1c2VyIiwiZXhwcmVzc2lvbiIsImFjdGl2YXRlZFF1ZXVlIiwidXBkYXRlZFF1ZXVlIiwiY2FsbEFjdGl2YXRlZEhvb2tzIiwiY2FsbFVwZGF0ZWRIb29rcyIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImlzUmVuZGVyV2F0Y2hlciIsImRlZXAiLCJsYXp5IiwiZGlydHkiLCJkZXBzIiwibmV3RGVwcyIsImRlcElkcyIsIm5ld0RlcElkcyIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInNvdXJjZUtleSIsInByb3h5R2V0dGVyIiwicHJveHlTZXR0ZXIiLCJpbml0U3RhdGUiLCJpbml0UHJvcHMiLCJpbml0TWV0aG9kcyIsImluaXREYXRhIiwiaW5pdENvbXB1dGVkIiwiaW5pdFdhdGNoIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwiaXNTU1IiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCJzaG91bGRDYWNoZSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlR2V0dGVySW52b2tlciIsImNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlV2F0Y2hlciIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsInVpZCQzIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJpbml0VXNlIiwicGx1Z2luIiwiaW5zdGFsbGVkUGx1Z2lucyIsIl9pbnN0YWxsZWRQbHVnaW5zIiwiaW5pdE1peGluJDEiLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJwcnVuZUNhY2hlIiwia2VlcEFsaXZlSW5zdGFuY2UiLCJjYWNoZWROb2RlIiwicHJ1bmVDYWNoZUVudHJ5IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJtb3VudGVkIiwicmVmJDEiLCJwYXJzZUludCIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsImRlbGV0ZSIsIm9ic2VydmFibGUiLCJzc3JDb250ZXh0IiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSIsImNvbnZlcnRFbnVtZXJhdGVkVmFsdWUiLCJpc0ZhbHN5QXR0clZhbHVlIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJkeW5hbWljQ2xhc3MiLCJzdHJpbmdpZnlDbGFzcyIsInN0cmluZ2lmeUFycmF5Iiwic3RyaW5naWZ5T2JqZWN0Iiwic3RyaW5naWZpZWQiLCJuYW1lc3BhY2VNYXAiLCJzdmciLCJtYXRoIiwiaXNIVE1MVGFnIiwiaXNTVkciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1RleHRJbnB1dFR5cGUiLCJzZWxlY3RlZCIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsInNldFN0eWxlU2NvcGUiLCJzY29wZUlkIiwibm9kZU9wcyIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpc1Vua25vd25FbGVtZW50JCQxIiwiaW5WUHJlIiwiaWdub3JlIiwiY3JlYXRpbmdFbG1JblZQcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJuZXN0ZWQiLCJvd25lckFycmF5Iiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwic2VlbktleXMiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImlubmVySFRNTCIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImZ1bGxJbnZva2UiLCJub2RlVHlwZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwiX2xlYXZlQ2IiLCJwYXRjaGFibGUiLCJpJDIiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiY2FsbEhvb2skMSIsIm9sZEFyZyIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsImJhc2VTZXRBdHRyIiwic2V0QXR0cmlidXRlTlMiLCJfX2llcGgiLCJibG9ja2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyJDEiLCJyZW1vdmUkMiIsInVzZU1pY3JvdGFza0ZpeCIsImFkZCQxIiwiYXR0YWNoZWRUaW1lc3RhbXAiLCJfd3JhcHBlciIsIm93bmVyRG9jdW1lbnQiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJldmVudHMiLCJzdmdDb250YWluZXIiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzTm90SW5Gb2N1c0FuZERpcnR5IiwiaXNEaXJ0eVdpdGhNb2RpZmllcnMiLCJub3RJbkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwibnVtYmVyIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJ3aGl0ZXNwYWNlUkUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRlZCIsIm9uRW5kIiwidHJhbnNmb3JtUkUiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsInMiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJhcHBlYXJDbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiYmVmb3JlTGVhdmUiLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwicGVyZm9ybUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsInRyaWdnZXIiLCJkaXJlY3RpdmUiLCJfdk9wdGlvbnMiLCJzZXRTZWxlY3RlZCIsImdldFZhbHVlIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsInByZXZPcHRpb25zIiwiY3VyT3B0aW9ucyIsIm8iLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiYWN0dWFsbHlTZXRTZWxlY3RlZCIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJzZWxlY3RlZEluZGV4IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJpc05vdFRleHROb2RlIiwiaXNWU2hvd0RpcmVjdGl2ZSIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwiYmVmb3JlTW91bnQiLCJrZXB0IiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJfcmVmbG93IiwiYm9keSIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJkeSIsInBsYXRmb3JtQ29tcG9uZW50cyIsImciLCJBcHAiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTtRQUNBO1FBQ0EsUUFBUSxvQkFBb0I7UUFDNUI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7UUFFQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7Ozs7UUFJQTtRQUNBO1FBQ0EsMENBQTBDO1FBQzFDOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTs7O1FBR0E7O1FBRUE7UUFDQSxpQ0FBaUM7O1FBRWpDO1FBQ0E7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBO1FBQ0E7UUFDQSxNQUFNO1FBQ047O1FBRUE7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx3QkFBd0Isa0NBQWtDO1FBQzFELE1BQU07UUFDTjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNB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SSxRQUFNLEVBQU5BLCtDQURNO0FBRU4vRCxRQUFNLEVBQUUsZ0JBQUFJLENBQUM7QUFBQSxXQUFJQSxDQUFDLENBQUN3N0MsZ0RBQUQsQ0FBTDtBQUFBO0FBRkgsQ0FBUixFQUdHMW1CLE1BSEgsQ0FHVSxNQUhWLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFFQXBvQiwyQ0FBRyxDQUFDdU4sR0FBSixDQUFRaEIsa0RBQVI7QUFFQSxJQUFNL0ssTUFBTSxHQUFHLENBQ2I7QUFDRXZzQixNQUFJLEVBQUUsR0FEUjtBQUVFcWYsV0FBUyxFQUFFO0FBQUEsV0FBTSwrS0FBTjtBQUFBO0FBRmIsQ0FEYSxFQUtiO0FBQ0V2bEIsTUFBSSxFQUFFLFVBRFI7QUFFRWtHLE1BQUksRUFBRSxXQUZSO0FBR0VxZixXQUFTLEVBQUU7QUFBQSxXQUFNLHFIQUFOO0FBQUE7QUFIYixDQUxhLEVBVWI7QUFDRXZsQixNQUFJLEVBQUUsT0FEUjtBQUVFa0csTUFBSSxFQUFFLFFBRlI7QUFHRXFmLFdBQVMsRUFBRTtBQUFBLFdBQU0sK0dBQU47QUFBQTtBQUhiLENBVmEsRUFlYjtBQUNFdmxCLE1BQUksRUFBRSxNQURSO0FBRUVrRyxNQUFJLEVBQUUsT0FGUjtBQUdFcWYsV0FBUyxFQUFFO0FBQUEsV0FBTSwrS0FBTjtBQUFBO0FBSGIsQ0FmYSxDQUFmO0FBc0JlLG1FQUFJaVksa0RBQUosQ0FBYztBQUMzQi91QixNQUFJLEVBQUUsU0FEcUI7QUFFM0Jna0IsUUFBTSxFQUFOQTtBQUYyQixDQUFkLENBQWYsRSIsImZpbGUiOiJtYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG4gXHRmdW5jdGlvbiB3ZWJwYWNrSnNvbnBDYWxsYmFjayhkYXRhKSB7XG4gXHRcdHZhciBjaHVua0lkcyA9IGRhdGFbMF07XG4gXHRcdHZhciBtb3JlTW9kdWxlcyA9IGRhdGFbMV07XG5cblxuIFx0XHQvLyBhZGQgXCJtb3JlTW9kdWxlc1wiIHRvIHRoZSBtb2R1bGVzIG9iamVjdCxcbiBcdFx0Ly8gdGhlbiBmbGFnIGFsbCBcImNodW5rSWRzXCIgYXMgbG9hZGVkIGFuZCBmaXJlIGNhbGxiYWNrXG4gXHRcdHZhciBtb2R1bGVJZCwgY2h1bmtJZCwgaSA9IDAsIHJlc29sdmVzID0gW107XG4gXHRcdGZvcig7aSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0Y2h1bmtJZCA9IGNodW5rSWRzW2ldO1xuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpICYmIGluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1xuIFx0XHRcdFx0cmVzb2x2ZXMucHVzaChpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0pO1xuIFx0XHRcdH1cbiBcdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuIFx0XHR9XG4gXHRcdGZvcihtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHRtb2R1bGVzW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdH1cbiBcdFx0aWYocGFyZW50SnNvbnBGdW5jdGlvbikgcGFyZW50SnNvbnBGdW5jdGlvbihkYXRhKTtcblxuIFx0XHR3aGlsZShyZXNvbHZlcy5sZW5ndGgpIHtcbiBcdFx0XHRyZXNvbHZlcy5zaGlmdCgpKCk7XG4gXHRcdH1cblxuIFx0fTtcblxuXG4gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuIFx0Ly8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4gXHQvLyBQcm9taXNlID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxuIFx0dmFyIGluc3RhbGxlZENodW5rcyA9IHtcbiBcdFx0XCJtYWluXCI6IDBcbiBcdH07XG5cblxuXG4gXHQvLyBzY3JpcHQgcGF0aCBmdW5jdGlvblxuIFx0ZnVuY3Rpb24ganNvbnBTY3JpcHRTcmMoY2h1bmtJZCkge1xuIFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArICh7fVtjaHVua0lkXXx8Y2h1bmtJZCkgKyBcIi5jaHVuay5qc1wiXG4gXHR9XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuIFx0Ly8gVGhpcyBmaWxlIGNvbnRhaW5zIG9ubHkgdGhlIGVudHJ5IGNodW5rLlxuIFx0Ly8gVGhlIGNodW5rIGxvYWRpbmcgZnVuY3Rpb24gZm9yIGFkZGl0aW9uYWwgY2h1bmtzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmUgPSBmdW5jdGlvbiByZXF1aXJlRW5zdXJlKGNodW5rSWQpIHtcbiBcdFx0dmFyIHByb21pc2VzID0gW107XG5cblxuIFx0XHQvLyBKU09OUCBjaHVuayBsb2FkaW5nIGZvciBqYXZhc2NyaXB0XG5cbiBcdFx0dmFyIGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbiBcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhICE9PSAwKSB7IC8vIDAgbWVhbnMgXCJhbHJlYWR5IGluc3RhbGxlZFwiLlxuXG4gXHRcdFx0Ly8gYSBQcm9taXNlIG1lYW5zIFwiY3VycmVudGx5IGxvYWRpbmdcIi5cbiBcdFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEpIHtcbiBcdFx0XHRcdHByb21pc2VzLnB1c2goaW5zdGFsbGVkQ2h1bmtEYXRhWzJdKTtcbiBcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0Ly8gc2V0dXAgUHJvbWlzZSBpbiBjaHVuayBjYWNoZVxuIFx0XHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiBcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gW3Jlc29sdmUsIHJlamVjdF07XG4gXHRcdFx0XHR9KTtcbiBcdFx0XHRcdHByb21pc2VzLnB1c2goaW5zdGFsbGVkQ2h1bmtEYXRhWzJdID0gcHJvbWlzZSk7XG5cbiBcdFx0XHRcdC8vIHN0YXJ0IGNodW5rIGxvYWRpbmdcbiBcdFx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiBcdFx0XHRcdHZhciBvblNjcmlwdENvbXBsZXRlO1xuXG4gXHRcdFx0XHRzY3JpcHQuY2hhcnNldCA9ICd1dGYtOCc7XG4gXHRcdFx0XHRzY3JpcHQudGltZW91dCA9IDEyMDtcbiBcdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKSB7XG4gXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdHNjcmlwdC5zcmMgPSBqc29ucFNjcmlwdFNyYyhjaHVua0lkKTtcblxuIFx0XHRcdFx0Ly8gY3JlYXRlIGVycm9yIGJlZm9yZSBzdGFjayB1bndvdW5kIHRvIGdldCB1c2VmdWwgc3RhY2t0cmFjZSBsYXRlclxuIFx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKCk7XG4gXHRcdFx0XHRvblNjcmlwdENvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gXHRcdFx0XHRcdC8vIGF2b2lkIG1lbSBsZWFrcyBpbiBJRS5cbiBcdFx0XHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gbnVsbDtcbiBcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuIFx0XHRcdFx0XHR2YXIgY2h1bmsgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHRcdFx0XHRcdGlmKGNodW5rICE9PSAwKSB7XG4gXHRcdFx0XHRcdFx0aWYoY2h1bmspIHtcbiBcdFx0XHRcdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG4gXHRcdFx0XHRcdFx0XHR2YXIgcmVhbFNyYyA9IGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQuc3JjO1xuIFx0XHRcdFx0XHRcdFx0ZXJyb3IubWVzc2FnZSA9ICdMb2FkaW5nIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuXFxuKCcgKyBlcnJvclR5cGUgKyAnOiAnICsgcmVhbFNyYyArICcpJztcbiBcdFx0XHRcdFx0XHRcdGVycm9yLm5hbWUgPSAnQ2h1bmtMb2FkRXJyb3InO1xuIFx0XHRcdFx0XHRcdFx0ZXJyb3IudHlwZSA9IGVycm9yVHlwZTtcbiBcdFx0XHRcdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZWFsU3JjO1xuIFx0XHRcdFx0XHRcdFx0Y2h1bmtbMV0oZXJyb3IpO1xuIFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSB1bmRlZmluZWQ7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH07XG4gXHRcdFx0XHR2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiBcdFx0XHRcdFx0b25TY3JpcHRDb21wbGV0ZSh7IHR5cGU6ICd0aW1lb3V0JywgdGFyZ2V0OiBzY3JpcHQgfSk7XG4gXHRcdFx0XHR9LCAxMjAwMDApO1xuIFx0XHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZTtcbiBcdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiBcdFx0XHR9XG4gXHRcdH1cbiBcdFx0cmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiBcdH07XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gb24gZXJyb3IgZnVuY3Rpb24gZm9yIGFzeW5jIGxvYWRpbmdcbiBcdF9fd2VicGFja19yZXF1aXJlX18ub2UgPSBmdW5jdGlvbihlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB0aHJvdyBlcnI7IH07XG5cbiBcdHZhciBqc29ucEFycmF5ID0gd2luZG93W1wid2VicGFja0pzb25wXCJdID0gd2luZG93W1wid2VicGFja0pzb25wXCJdIHx8IFtdO1xuIFx0dmFyIG9sZEpzb25wRnVuY3Rpb24gPSBqc29ucEFycmF5LnB1c2guYmluZChqc29ucEFycmF5KTtcbiBcdGpzb25wQXJyYXkucHVzaCA9IHdlYnBhY2tKc29ucENhbGxiYWNrO1xuIFx0anNvbnBBcnJheSA9IGpzb25wQXJyYXkuc2xpY2UoKTtcbiBcdGZvcih2YXIgaSA9IDA7IGkgPCBqc29ucEFycmF5Lmxlbmd0aDsgaSsrKSB3ZWJwYWNrSnNvbnBDYWxsYmFjayhqc29ucEFycmF5W2ldKTtcbiBcdHZhciBwYXJlbnRKc29ucEZ1bmN0aW9uID0gb2xkSnNvbnBGdW5jdGlvbjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvbWFpbi5qc1wiKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCAnICsgKG5hbWUgPyBuYW1lICsgJyAnIDogJycpICsgJ2ludm9jYXRpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG4iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0KTtcbiAgICB9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgRU5UUklFUykge1xuICB0cnkge1xuICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdmFyIHJldHVybk1ldGhvZCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0dXJuTWV0aG9kICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldHVybk1ldGhvZC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgY2xhc3NvZlJhdyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vd24ta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhcyh0YXJnZXQsIGtleSkpIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgfVxufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwiLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCJ2YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT0gJ2Z1bmN0aW9uJyA/IHZhcmlhYmxlIDogdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKHBhdGhbbmFtZXNwYWNlXSkgfHwgYUZ1bmN0aW9uKGdsb2JhbFtuYW1lc3BhY2VdKVxuICAgIDogcGF0aFtuYW1lc3BhY2VdICYmIHBhdGhbbmFtZXNwYWNlXVttZXRob2RdIHx8IGdsb2JhbFtuYW1lc3BhY2VdICYmIGdsb2JhbFtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwidmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxubW9kdWxlLmV4cG9ydHMgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGU7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gY29uc29sZS5lcnJvcihhKSA6IGNvbnNvbGUuZXJyb3IoYSwgYik7XG4gIH1cbn07XG4iLCJ2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xuXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbnZhciBzcGxpdCA9ICcnLnNwbGl0O1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoaXQpID09ICdTdHJpbmcnID8gc3BsaXQuY2FsbChpdCwgJycpIDogT2JqZWN0KGl0KTtcbn0gOiBPYmplY3Q7XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gRnVuY3Rpb24udG9TdHJpbmc7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAodHlwZW9mIHN0b3JlLmluc3BlY3RTb3VyY2UgIT0gJ2Z1bmN0aW9uJykge1xuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcbiIsInZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBvYmplY3RIYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG52YXIgc2V0LCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQKSB7XG4gIHZhciBzdG9yZSA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciB3bWdldCA9IHN0b3JlLmdldDtcbiAgdmFyIHdtaGFzID0gc3RvcmUuaGFzO1xuICB2YXIgd21zZXQgPSBzdG9yZS5zZXQ7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICB3bXNldC5jYWxsKHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0LmNhbGwoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcbiAgaGlkZGVuS2V5c1tTVEFURV0gPSB0cnVlO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWVcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXG4gICAgOiB0eXBlb2YgZGV0ZWN0aW9uID09ICdmdW5jdGlvbicgPyBmYWlscyhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZC5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZC5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9ICdQJztcblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZvcmNlZDtcbiIsInZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlci1hZ2VudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IC8oaXBob25lfGlwb2R8aXBhZCkuKmFwcGxld2Via2l0L2kudGVzdCh1c2VyQWdlbnQpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2JpbmQtY29udGV4dCcpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nJyk7XG5cbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xufTtcblxudmFyIGl0ZXJhdGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZm4sIHRoYXQsIEFTX0VOVFJJRVMsIElTX0lURVJBVE9SKSB7XG4gIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChmbiwgdGhhdCwgQVNfRU5UUklFUyA/IDIgOiAxKTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IEFTX0VOVFJJRVNcbiAgICAgICAgICA/IGJvdW5kRnVuY3Rpb24oYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pXG4gICAgICAgICAgOiBib3VuZEZ1bmN0aW9uKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpO1xuICB9XG5cbiAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gIHdoaWxlICghKHN0ZXAgPSBuZXh0LmNhbGwoaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgcmVzdWx0ID0gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgYm91bmRGdW5jdGlvbiwgc3RlcC52YWx1ZSwgQVNfRU5UUklFUyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ29iamVjdCcgJiYgcmVzdWx0ICYmIHJlc3VsdCBpbnN0YW5jZW9mIFJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG59O1xuXG5pdGVyYXRlLnN0b3AgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHJldHVybiBuZXcgUmVzdWx0KHRydWUsIHJlc3VsdCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdGFzaycpLnNldDtcbnZhciBJU19JT1MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtaW9zJyk7XG5cbnZhciBNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBJU19OT0RFID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG4vLyBOb2RlLmpzIDExIHNob3dzIEV4cGVyaW1lbnRhbFdhcm5pbmcgb24gZ2V0dGluZyBgcXVldWVNaWNyb3Rhc2tgXG52YXIgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdsb2JhbCwgJ3F1ZXVlTWljcm90YXNrJyk7XG52YXIgcXVldWVNaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgJiYgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yLnZhbHVlO1xuXG52YXIgZmx1c2gsIGhlYWQsIGxhc3QsIG5vdGlmeSwgdG9nZ2xlLCBub2RlLCBwcm9taXNlLCB0aGVuO1xuXG4vLyBtb2Rlcm4gZW5naW5lcyBoYXZlIHF1ZXVlTWljcm90YXNrIG1ldGhvZFxuaWYgKCFxdWV1ZU1pY3JvdGFzaykge1xuICBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoSVNfTk9ERSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoSVNfTk9ERSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgfSBlbHNlIGlmIChNdXRhdGlvbk9ic2VydmVyICYmICFJU19JT1MpIHtcbiAgICB0b2dnbGUgPSB0cnVlO1xuICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIHRoZW4gPSBwcm9taXNlLnRoZW47XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhlbi5jYWxsKHByb21pc2UsIGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1ZXVlTWljcm90YXNrIHx8IGZ1bmN0aW9uIChmbikge1xuICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gIGlmICghaGVhZCkge1xuICAgIGhlYWQgPSB0YXNrO1xuICAgIG5vdGlmeSgpO1xuICB9IGxhc3QgPSB0YXNrO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLlByb21pc2U7XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHJldHVybiAhU3RyaW5nKFN5bWJvbCgpKTtcbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlJyk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UoV2Vha01hcCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG5cbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59O1xuXG4vLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcblxudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcblxudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsInZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG5cbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpLmluZGV4T2Y7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzKGhpZGRlbktleXMsIGtleSkgJiYgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5pbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgIW5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG59O1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlLCB2YWx1ZTogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIHZhbHVlOiBlcnJvciB9O1xuICB9XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIG9wdGlvbnMpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG4gIHZhciBub1RhcmdldEdldCA9IG9wdGlvbnMgPyAhIW9wdGlvbnMubm9UYXJnZXRHZXQgOiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgJiYgIWhhcyh2YWx1ZSwgJ25hbWUnKSkgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIGtleSk7XG4gICAgZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/IGtleSA6ICcnKTtcbiAgfVxuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICB9IGVsc2UgaWYgKCFub1RhcmdldEdldCAmJiBPW2tleV0pIHtcbiAgICBzaW1wbGUgPSB0cnVlO1xuICB9XG4gIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICBlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCBrZXksIHZhbHVlKTtcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcbn0pO1xuIiwiLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShnbG9iYWwsIGtleSwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbFtrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4oQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTXSkge1xuICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9KTtcbiAgfVxufTtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVEFHLCBTVEFUSUMpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShpdCwgVE9fU1RSSU5HX1RBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcblxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHNldEdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtZ2xvYmFsJyk7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZTtcbiIsInZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjYuMScsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUZ1bmN0aW9uKFMpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9iaW5kLWNvbnRleHQnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG52YXIgSVNfSU9TID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWlvcycpO1xuXG52YXIgbG9jYXRpb24gPSBnbG9iYWwubG9jYXRpb247XG52YXIgc2V0ID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhciA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcblxudmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xuXG52YXIgcnVubmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcnVuKGlkKTtcbiAgfTtcbn07XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4oZXZlbnQuZGF0YSk7XG59O1xuXG52YXIgcG9zdCA9IGZ1bmN0aW9uIChpZCkge1xuICAvLyBvbGQgZW5naW5lcyBoYXZlIG5vdCBsb2NhdGlvbi5vcmlnaW5cbiAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QpO1xufTtcblxuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXQgfHwgIWNsZWFyKSB7XG4gIHNldCA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSkuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhciA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3cocnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICAvLyBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzYyNFxuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsICYmICFJU19JT1MpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGJpbmQocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyAmJiAhZmFpbHMocG9zdCkpIHtcbiAgICBkZWZlciA9IHBvc3Q7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bihpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQocnVubmVyKGlkKSwgMCk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGNsZWFyOiBjbGVhclxufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG4iLCIvLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuIiwidmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW50ZWdlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzTmFOKGFyZ3VtZW50ID0gK2FyZ3VtZW50KSA/IDAgOiAoYXJndW1lbnQgPiAwID8gZmxvb3IgOiBjZWlsKShhcmd1bWVudCk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBQUkVGRVJSRURfU1RSSU5HKSB7XG4gIGlmICghaXNPYmplY3QoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpbnB1dC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xuXG50ZXN0W1RPX1NUUklOR19UQUddID0gJ3onO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuIiwidmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuIiwidmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICYmICFTeW1ib2wuc2hhbVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VzZXItYWdlbnQnKTtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gKyBtYXRjaFsxXTtcbn0gZWxzZSBpZiAodXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJzaW9uICYmICt2ZXJzaW9uO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wnKTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZCcpO1xuXG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sIDogU3ltYm9sICYmIFN5bWJvbC53aXRob3V0U2V0dGVyIHx8IHVpZDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhcyhXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpKSB7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzKFN5bWJvbCwgbmFtZSkpIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbFtuYW1lXTtcbiAgICBlbHNlIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbCgnU3ltYm9sLicgKyBuYW1lKTtcbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcbiIsInZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nJyk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbmlmICghVE9fU1RSSU5HX1RBR19TVVBQT1JUKSB7XG4gIHJlZGVmaW5lKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIHRvU3RyaW5nLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIE5hdGl2ZVByb21pc2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXByb21pc2UtY29uc3RydWN0b3InKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lLWFsbCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtc3BlY2llcycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlJyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRlJyk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9taWNyb3Rhc2snKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLXJlc29sdmUnKTtcbnZhciBob3N0UmVwb3J0RXJyb3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hvc3QtcmVwb3J0LWVycm9ycycpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BlcmZvcm0nKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92OC12ZXJzaW9uJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yID0gTmF0aXZlUHJvbWlzZTtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkZmV0Y2ggPSBnZXRCdWlsdEluKCdmZXRjaCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcbnZhciBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eTtcbnZhciBJU19OT0RFID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgRElTUEFUQ0hfRVZFTlQgPSAhIShkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFdmVudCAmJiBnbG9iYWwuZGlzcGF0Y2hFdmVudCk7XG52YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xudmFyIFJFSkVDVElPTl9IQU5ETEVEID0gJ3JlamVjdGlvbmhhbmRsZWQnO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xudmFyIEhBTkRMRUQgPSAxO1xudmFyIFVOSEFORExFRCA9IDI7XG52YXIgSW50ZXJuYWwsIE93blByb21pc2VDYXBhYmlsaXR5LCBQcm9taXNlV3JhcHBlciwgbmF0aXZlVGhlbjtcblxudmFyIEZPUkNFRCA9IGlzRm9yY2VkKFBST01JU0UsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBpbnNwZWN0U291cmNlKFByb21pc2VDb25zdHJ1Y3RvcikgIT09IFN0cmluZyhQcm9taXNlQ29uc3RydWN0b3IpO1xuICBpZiAoIUdMT0JBTF9DT1JFX0pTX1BST01JU0UpIHtcbiAgICAvLyBWOCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gICAgLy8gV2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgICBpZiAoVjhfVkVSU0lPTiA9PT0gNjYpIHJldHVybiB0cnVlO1xuICAgIC8vIFVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICBpZiAoIUlTX05PREUgJiYgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCAhPSAnZnVuY3Rpb24nKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBXZSBuZWVkIFByb21pc2UjZmluYWxseSBpbiB0aGUgcHVyZSB2ZXJzaW9uIGZvciBwcmV2ZW50aW5nIHByb3RvdHlwZSBwb2xsdXRpb25cbiAgaWYgKElTX1BVUkUgJiYgIVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGVbJ2ZpbmFsbHknXSkgcmV0dXJuIHRydWU7XG4gIC8vIFdlIGNhbid0IHVzZSBAQHNwZWNpZXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG4gIGlmIChWOF9WRVJTSU9OID49IDUxICYmIC9uYXRpdmUgY29kZS8udGVzdChQcm9taXNlQ29uc3RydWN0b3IpKSByZXR1cm4gZmFsc2U7XG4gIC8vIERldGVjdCBjb3JyZWN0bmVzcyBvZiBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZUNvbnN0cnVjdG9yLnJlc29sdmUoMSk7XG4gIHZhciBGYWtlUHJvbWlzZSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgZXhlYyhmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG4gIH07XG4gIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3IgPSB7fTtcbiAgY29uc3RydWN0b3JbU1BFQ0lFU10gPSBGYWtlUHJvbWlzZTtcbiAgcmV0dXJuICEocHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZSk7XG59KTtcblxudmFyIElOQ09SUkVDVF9JVEVSQVRJT04gPSBGT1JDRUQgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgUHJvbWlzZUNvbnN0cnVjdG9yLmFsbChpdGVyYWJsZSlbJ2NhdGNoJ10oZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSwgaXNSZWplY3QpIHtcbiAgaWYgKHN0YXRlLm5vdGlmaWVkKSByZXR1cm47XG4gIHN0YXRlLm5vdGlmaWVkID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gc3RhdGUucmVhY3Rpb25zO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICAgIHZhciBvayA9IHN0YXRlLnN0YXRlID09IEZVTEZJTExFRDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBjaGFpbltpbmRleCsrXTtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlamVjdGlvbiA9PT0gVU5IQU5ETEVEKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlLCBzdGF0ZSk7XG4gICAgICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBjYW4gdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLnJlYWN0aW9ucyA9IFtdO1xuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHByb21pc2UsIHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LnByb21pc2UgPSBwcm9taXNlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC5pbml0RXZlbnQobmFtZSwgZmFsc2UsIHRydWUpO1xuICAgIGdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSBlbHNlIGV2ZW50ID0geyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHJlYXNvbiB9O1xuICBpZiAoaGFuZGxlciA9IGdsb2JhbFsnb24nICsgbmFtZV0pIGhhbmRsZXIoZXZlbnQpO1xuICBlbHNlIGlmIChuYW1lID09PSBVTkhBTkRMRURfUkVKRUNUSU9OKSBob3N0UmVwb3J0RXJyb3JzKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCByZWFzb24pO1xufTtcblxudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKElTX1VOSEFORExFRCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChJU19OT0RFKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFVOSEFORExFRF9SRUpFQ1RJT04sIHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHN0YXRlLnJlamVjdGlvbiA9IElTX05PREUgfHwgaXNVbmhhbmRsZWQoc3RhdGUpID8gVU5IQU5ETEVEIDogSEFORExFRDtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRocm93IHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5yZWplY3Rpb24gIT09IEhBTkRMRUQgJiYgIXN0YXRlLnBhcmVudDtcbn07XG5cbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKElTX05PREUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFJFSkVDVElPTl9IQU5ETEVELCBwcm9taXNlLCBzdGF0ZS52YWx1ZSk7XG4gIH0pO1xufTtcblxudmFyIGJpbmQgPSBmdW5jdGlvbiAoZm4sIHByb21pc2UsIHN0YXRlLCB1bndyYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGZuKHByb21pc2UsIHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiAgfTtcbn07XG5cbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gIHN0YXRlLnN0YXRlID0gUkVKRUNURUQ7XG4gIG5vdGlmeShwcm9taXNlLCBzdGF0ZSwgdHJ1ZSk7XG59O1xuXG52YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIHZhciB0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSk7XG4gICAgaWYgKHRoZW4pIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBkb25lOiBmYWxzZSB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSxcbiAgICAgICAgICAgIGJpbmQoaW50ZXJuYWxSZXNvbHZlLCBwcm9taXNlLCB3cmFwcGVyLCBzdGF0ZSksXG4gICAgICAgICAgICBiaW5kKGludGVybmFsUmVqZWN0LCBwcm9taXNlLCB3cmFwcGVyLCBzdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGludGVybmFsUmVqZWN0KHByb21pc2UsIHdyYXBwZXIsIGVycm9yLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgc3RhdGUuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgICBub3RpZnkocHJvbWlzZSwgc3RhdGUsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW50ZXJuYWxSZWplY3QocHJvbWlzZSwgeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKEZPUkNFRCkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihiaW5kKGludGVybmFsUmVzb2x2ZSwgdGhpcywgc3RhdGUpLCBiaW5kKGludGVybmFsUmVqZWN0LCB0aGlzLCBzdGF0ZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpbnRlcm5hbFJlamVjdCh0aGlzLCBzdGF0ZSwgZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgdHlwZTogUFJPTUlTRSxcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgbm90aWZpZWQ6IGZhbHNlLFxuICAgICAgcGFyZW50OiBmYWxzZSxcbiAgICAgIHJlYWN0aW9uczogW10sXG4gICAgICByZWplY3Rpb246IGZhbHNlLFxuICAgICAgc3RhdGU6IFBFTkRJTkcsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKFByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgICAvLyBgUHJvbWlzZS5wcm90b3R5cGUudGhlbmAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUudGhlblxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIFByb21pc2VDb25zdHJ1Y3RvcikpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBJU19OT0RFID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5wYXJlbnQgPSB0cnVlO1xuICAgICAgc3RhdGUucmVhY3Rpb25zLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHN0YXRlLnN0YXRlICE9IFBFTkRJTkcpIG5vdGlmeSh0aGlzLCBzdGF0ZSwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyBgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmNhdGNoXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUocHJvbWlzZSk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBiaW5kKGludGVybmFsUmVzb2x2ZSwgcHJvbWlzZSwgc3RhdGUpO1xuICAgIHRoaXMucmVqZWN0ID0gYmluZChpbnRlcm5hbFJlamVjdCwgcHJvbWlzZSwgc3RhdGUpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSBQcm9taXNlQ29uc3RydWN0b3IgfHwgQyA9PT0gUHJvbWlzZVdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcblxuICBpZiAoIUlTX1BVUkUgJiYgdHlwZW9mIE5hdGl2ZVByb21pc2UgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG5hdGl2ZVRoZW4gPSBOYXRpdmVQcm9taXNlLnByb3RvdHlwZS50aGVuO1xuXG4gICAgLy8gd3JhcCBuYXRpdmUgUHJvbWlzZSN0aGVuIGZvciBuYXRpdmUgYXN5bmMgZnVuY3Rpb25zXG4gICAgcmVkZWZpbmUoTmF0aXZlUHJvbWlzZS5wcm90b3R5cGUsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBuYXRpdmVUaGVuLmNhbGwodGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NDBcbiAgICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcblxuICAgIC8vIHdyYXAgZmV0Y2ggcmVzdWx0XG4gICAgaWYgKHR5cGVvZiAkZmV0Y2ggPT0gJ2Z1bmN0aW9uJykgJCh7IGdsb2JhbDogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKGlucHV0IC8qICwgaW5pdCAqLykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoUHJvbWlzZUNvbnN0cnVjdG9yLCAkZmV0Y2guYXBwbHkoZ2xvYmFsLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4kKHsgZ2xvYmFsOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIFByb21pc2U6IFByb21pc2VDb25zdHJ1Y3RvclxufSk7XG5cbnNldFRvU3RyaW5nVGFnKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UsIHRydWUpO1xuc2V0U3BlY2llcyhQUk9NSVNFKTtcblxuUHJvbWlzZVdyYXBwZXIgPSBnZXRCdWlsdEluKFBST01JU0UpO1xuXG4vLyBzdGF0aWNzXG4kKHsgdGFyZ2V0OiBQUk9NSVNFLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIC8vIGBQcm9taXNlLnJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucmVqZWN0XG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIGNhcGFiaWxpdHkucmVqZWN0LmNhbGwodW5kZWZpbmVkLCByKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxuJCh7IHRhcmdldDogUFJPTUlTRSwgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJU19QVVJFIHx8IEZPUkNFRCB9LCB7XG4gIC8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKElTX1BVUkUgJiYgdGhpcyA9PT0gUHJvbWlzZVdyYXBwZXIgPyBQcm9taXNlQ29uc3RydWN0b3IgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG5cbiQoeyB0YXJnZXQ6IFBST01JU0UsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIC8vIGBQcm9taXNlLmFsbGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UuYWxsXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhRnVuY3Rpb24oQy5yZXNvbHZlKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgJHByb21pc2VSZXNvbHZlLmNhbGwoQywgcHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyBgUHJvbWlzZS5yYWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5yYWNlXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFGdW5jdGlvbihDLnJlc29sdmUpO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgJHByb21pc2VSZXNvbHZlLmNhbGwoQywgcHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO1xcbi8qIVxcbiAqIHJlc3MuY3NzIOKAoiB2Mi4wLjJcXG4gKiBNSVQgTGljZW5zZVxcbiAqIGdpdGh1Yi5jb20vZmlsaXBlbGluaGFyZXMvcmVzc1xcbiAqL1xcbi8qICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAjIEdsb2JhbCBzZWxlY3RvcnNcXG4gICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuaHRtbCB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xcbiAgLyogUHJldmVudCBhZGp1c3RtZW50cyBvZiBmb250IHNpemUgYWZ0ZXIgb3JpZW50YXRpb24gY2hhbmdlcyBpbiBpT1MgKi9cXG4gIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XFxuICAtbW96LXRhYi1zaXplOiA0O1xcbiAgdGFiLXNpemU6IDQ7IH1cXG5cXG4qLFxcbjo6YmVmb3JlLFxcbjo6YWZ0ZXIge1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIC8qIFNldCBgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdGAgdG8gYWxsIGVsZW1lbnRzIGFuZCBwc2V1ZG8gZWxlbWVudHMgKi9cXG4gIGJveC1zaXppbmc6IGluaGVyaXQ7IH1cXG5cXG46OmJlZm9yZSxcXG46OmFmdGVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogaW5oZXJpdDtcXG4gIC8qIEluaGVyaXQgdGV4dC1kZWNvcmF0aW9uIGFuZCB2ZXJ0aWNhbCBhbGlnbiB0byA6OmJlZm9yZSBhbmQgOjphZnRlciBwc2V1ZG8gZWxlbWVudHMgKi9cXG4gIHZlcnRpY2FsLWFsaWduOiBpbmhlcml0OyB9XFxuXFxuKiB7XFxuICBwYWRkaW5nOiAwO1xcbiAgLyogUmVzZXQgYHBhZGRpbmdgIGFuZCBgbWFyZ2luYCBvZiBhbGwgZWxlbWVudHMgKi9cXG4gIG1hcmdpbjogMDsgfVxcblxcbi8qICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgICMgR2VuZXJhbCBlbGVtZW50c1xcbiAgICAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbmhyIHtcXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgLyogU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZSBhbmQgSUUgKi9cXG4gIGhlaWdodDogMDtcXG4gIC8qIEFkZCB0aGUgY29ycmVjdCBib3ggc2l6aW5nIGluIEZpcmVmb3ggKi8gfVxcblxcbmRldGFpbHMsXFxubWFpbiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIC8qIFJlbmRlciB0aGUgYG1haW5gIGVsZW1lbnQgY29uc2lzdGVudGx5IGluIElFLiAqLyB9XFxuXFxuc3VtbWFyeSB7XFxuICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxuICAvKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBhbGwgYnJvd3NlcnMgKi8gfVxcblxcbnNtYWxsIHtcXG4gIGZvbnQtc2l6ZTogODAlO1xcbiAgLyogU2V0IGZvbnQtc2l6ZSB0byA4MCUgaW4gYHNtYWxsYCBlbGVtZW50cyAqLyB9XFxuXFxuW2hpZGRlbl0ge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIC8qIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFICovIH1cXG5cXG5hYmJyW3RpdGxlXSB7XFxuICBib3JkZXItYm90dG9tOiBub25lO1xcbiAgLyogUmVtb3ZlIHRoZSBib3R0b20gYm9yZGVyIGluIENocm9tZSA1NyAqL1xcbiAgLyogQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIElFLCBPcGVyYSwgYW5kIFNhZmFyaSAqL1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7IH1cXG5cXG5hIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgLyogUmVtb3ZlIHRoZSBncmF5IGJhY2tncm91bmQgb24gYWN0aXZlIGxpbmtzIGluIElFIDEwICovIH1cXG5cXG5hOmFjdGl2ZSxcXG5hOmhvdmVyIHtcXG4gIG91dGxpbmUtd2lkdGg6IDA7XFxuICAvKiBSZW1vdmUgdGhlIG91dGxpbmUgd2hlbiBob3ZlcmluZyBpbiBhbGwgYnJvd3NlcnMgKi8gfVxcblxcbmNvZGUsXFxua2JkLFxcbnByZSxcXG5zYW1wIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2UsIG1vbm9zcGFjZTtcXG4gIC8qIFNwZWNpZnkgdGhlIGZvbnQgZmFtaWx5IG9mIGNvZGUgZWxlbWVudHMgKi8gfVxcblxcbnByZSB7XFxuICBmb250LXNpemU6IDFlbTtcXG4gIC8qIENvcnJlY3QgdGhlIG9kZCBgZW1gIGZvbnQgc2l6aW5nIGluIGFsbCBicm93c2VycyAqLyB9XFxuXFxuYixcXG5zdHJvbmcge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gIC8qIEFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkgKi8gfVxcblxcbi8qIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3VucnV0aGxlc3MvNDEzOTMwICovXFxuc3ViLFxcbnN1cCB7XFxuICBmb250LXNpemU6IDc1JTtcXG4gIGxpbmUtaGVpZ2h0OiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lOyB9XFxuXFxuc3ViIHtcXG4gIGJvdHRvbTogLTAuMjVlbTsgfVxcblxcbnN1cCB7XFxuICB0b3A6IC0wLjVlbTsgfVxcblxcbi8qICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgICMgRm9ybXNcXG4gICAgICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5pbnB1dCB7XFxuICBib3JkZXItcmFkaXVzOiAwOyB9XFxuXFxuLyogUmVwbGFjZSBwb2ludGVyIGN1cnNvciBpbiBkaXNhYmxlZCBlbGVtZW50cyAqL1xcbltkaXNhYmxlZF0ge1xcbiAgY3Vyc29yOiBkZWZhdWx0OyB9XFxuXFxuW3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcblt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICBoZWlnaHQ6IGF1dG87XFxuICAvKiBDb3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBDaHJvbWUgKi8gfVxcblxcblt0eXBlPVxcXCJzZWFyY2hcXFwiXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDtcXG4gIC8qIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpICovXFxuICBvdXRsaW5lLW9mZnNldDogLTJweDsgfVxcblxcblt0eXBlPVxcXCJzZWFyY2hcXFwiXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAvKiBSZW1vdmUgdGhlIGlubmVyIHBhZGRpbmcgaW4gQ2hyb21lIGFuZCBTYWZhcmkgb24gbWFjT1MgKi8gfVxcblxcbnRleHRhcmVhIHtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbiAgLyogSW50ZXJuZXQgRXhwbG9yZXIgMTErICovXFxuICByZXNpemU6IHZlcnRpY2FsO1xcbiAgLyogU3BlY2lmeSB0ZXh0YXJlYSByZXNpemFiaWxpdHkgKi8gfVxcblxcbmJ1dHRvbixcXG5pbnB1dCxcXG5vcHRncm91cCxcXG5zZWxlY3QsXFxudGV4dGFyZWEge1xcbiAgZm9udDogaW5oZXJpdDtcXG4gIC8qIFNwZWNpZnkgZm9udCBpbmhlcml0YW5jZSBvZiBmb3JtIGVsZW1lbnRzICovIH1cXG5cXG5vcHRncm91cCB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIC8qIFJlc3RvcmUgdGhlIGZvbnQgd2VpZ2h0IHVuc2V0IGJ5IHRoZSBwcmV2aW91cyBydWxlICovIH1cXG5cXG5idXR0b24ge1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICAvKiBBZGRyZXNzIGBvdmVyZmxvd2Agc2V0IHRvIGBoaWRkZW5gIGluIElFIDgvOS8xMC8xMSAqLyB9XFxuXFxuYnV0dG9uLFxcbnNlbGVjdCB7XFxuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG4gIC8qIEZpcmVmb3ggNDArLCBJbnRlcm5ldCBFeHBsb3JlciAxMS0gKi8gfVxcblxcbi8qIEFwcGx5IGN1cnNvciBwb2ludGVyIHRvIGJ1dHRvbiBlbGVtZW50cyAqL1xcbmJ1dHRvbixcXG5bdHlwZT1cXFwiYnV0dG9uXFxcIl0sXFxuW3R5cGU9XFxcInJlc2V0XFxcIl0sXFxuW3R5cGU9XFxcInN1Ym1pdFxcXCJdLFxcbltyb2xlPVxcXCJidXR0b25cXFwiXSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBjb2xvcjogaW5oZXJpdDsgfVxcblxcbi8qIFJlbW92ZSBpbm5lciBwYWRkaW5nIGFuZCBib3JkZXIgaW4gRmlyZWZveCA0KyAqL1xcbmJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG5bdHlwZT1cXFwiYnV0dG9uXFxcIl06Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcInJlc2V0XFxcIl06Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcInN1Ym1pdFxcXCJdOjotbW96LWZvY3VzLWlubmVyIHtcXG4gIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gIHBhZGRpbmc6IDA7IH1cXG5cXG4vKiBSZXBsYWNlIGZvY3VzIHN0eWxlIHJlbW92ZWQgaW4gdGhlIGJvcmRlciByZXNldCBhYm92ZSAqL1xcbmJ1dHRvbjotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwiYnV0dG9uXFxcIl06Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcInJlc2V0XFxcIl06Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcInN1Ym1pdFxcXCJdOjotbW96LWZvY3VzLWlubmVyIHtcXG4gIG91dGxpbmU6IDFweCBkb3R0ZWQgQnV0dG9uVGV4dDsgfVxcblxcbmJ1dHRvbixcXG5odG1sIFt0eXBlPVxcXCJidXR0b25cXFwiXSxcXG5bdHlwZT1cXFwicmVzZXRcXFwiXSxcXG5bdHlwZT1cXFwic3VibWl0XFxcIl0ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAvKiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyAqLyB9XFxuXFxuLyogUmVtb3ZlIHRoZSBkZWZhdWx0IGJ1dHRvbiBzdHlsaW5nIGluIGFsbCBicm93c2VycyAqL1xcbmJ1dHRvbixcXG5pbnB1dCxcXG5zZWxlY3QsXFxudGV4dGFyZWEge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7IH1cXG5cXG4vKiBTdHlsZSBzZWxlY3QgbGlrZSBhIHN0YW5kYXJkIGlucHV0ICovXFxuc2VsZWN0IHtcXG4gIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXG4gIC8qIEZpcmVmb3ggMzYrICovXFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAvKiBDaHJvbWUgNDErICovIH1cXG5cXG5zZWxlY3Q6Oi1tcy1leHBhbmQge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIC8qIEludGVybmV0IEV4cGxvcmVyIDExKyAqLyB9XFxuXFxuc2VsZWN0OjotbXMtdmFsdWUge1xcbiAgY29sb3I6IGN1cnJlbnRDb2xvcjtcXG4gIC8qIEludGVybmV0IEV4cGxvcmVyIDExKyAqLyB9XFxuXFxubGVnZW5kIHtcXG4gIGJvcmRlcjogMDtcXG4gIC8qIENvcnJlY3QgYGNvbG9yYCBub3QgYmVpbmcgaW5oZXJpdGVkIGluIElFIDgvOS8xMC8xMSAqL1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICAvKiBDb3JyZWN0IHRoZSBjb2xvciBpbmhlcml0YW5jZSBmcm9tIGBmaWVsZHNldGAgZWxlbWVudHMgaW4gSUUgKi9cXG4gIGRpc3BsYXk6IHRhYmxlO1xcbiAgLyogQ29ycmVjdCB0aGUgdGV4dCB3cmFwcGluZyBpbiBFZGdlIGFuZCBJRSAqL1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgLyogQ29ycmVjdCB0aGUgdGV4dCB3cmFwcGluZyBpbiBFZGdlIGFuZCBJRSAqL1xcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXG4gIC8qIENvcnJlY3QgdGhlIHRleHQgd3JhcHBpbmcgaW4gRWRnZSBhbmQgSUUgKi9cXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIC8qIENvcnJlY3QgdGhlIHRleHQgd3JhcHBpbmcgaW4gRWRnZSAxOC0gYW5kIElFICovIH1cXG5cXG46Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gIC8qIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkgKi9cXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBmb250OiBpbmhlcml0O1xcbiAgLyogQ2hhbmdlIGZvbnQgcHJvcGVydGllcyB0byBgaW5oZXJpdGAgaW4gQ2hyb21lIGFuZCBTYWZhcmkgKi8gfVxcblxcbi8qICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgICMgU3BlY2lmeSBtZWRpYSBlbGVtZW50IHN0eWxlXFxuICAgICAjID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuaW1nIHtcXG4gIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gIC8qIFJlbW92ZSBib3JkZXIgd2hlbiBpbnNpZGUgYGFgIGVsZW1lbnQgaW4gSUUgOC85LzEwICovIH1cXG5cXG4vKiBBZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSwgRmlyZWZveCwgYW5kIE9wZXJhICovXFxucHJvZ3Jlc3Mge1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lOyB9XFxuXFxuc3ZnOm5vdChbZmlsbF0pIHtcXG4gIGZpbGw6IGN1cnJlbnRDb2xvcjsgfVxcblxcbi8qICMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgICMgQWNjZXNzaWJpbGl0eVxcbiAgICAgIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbi8qIEhpZGUgY29udGVudCBmcm9tIHNjcmVlbnMgYnV0IG5vdCBzY3JlZW5yZWFkZXJzICovXFxuQG1lZGlhIHNjcmVlbiB7XFxuICBbaGlkZGVufj1cXFwic2NyZWVuXFxcIl0ge1xcbiAgICBkaXNwbGF5OiBpbmhlcml0OyB9XFxuICBbaGlkZGVufj1cXFwic2NyZWVuXFxcIl06bm90KDphY3RpdmUpOm5vdCg6Zm9jdXMpOm5vdCg6dGFyZ2V0KSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50O1xcbiAgICBjbGlwOiByZWN0KDAgMCAwIDApICFpbXBvcnRhbnQ7IH0gfVxcblxcbi8qIFNwZWNpZnkgdGhlIHByb2dyZXNzIGN1cnNvciBvZiB1cGRhdGluZyBlbGVtZW50cyAqL1xcblthcmlhLWJ1c3k9XFxcInRydWVcXFwiXSB7XFxuICBjdXJzb3I6IHByb2dyZXNzOyB9XFxuXFxuLyogU3BlY2lmeSB0aGUgcG9pbnRlciBjdXJzb3Igb2YgdHJpZ2dlciBlbGVtZW50cyAqL1xcblthcmlhLWNvbnRyb2xzXSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7IH1cXG5cXG4vKiBTcGVjaWZ5IHRoZSB1bnN0eWxlZCBjdXJzb3Igb2YgZGlzYWJsZWQsIG5vdC1lZGl0YWJsZSwgb3Igb3RoZXJ3aXNlIGlub3BlcmFibGUgZWxlbWVudHMgKi9cXG5bYXJpYS1kaXNhYmxlZF0ge1xcbiAgY3Vyc29yOiBkZWZhdWx0OyB9XFxuXFxuYm9keSB7XFxuICBmb250LWZhbWlseTogYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxcXFwiSGlyYWdpbm8gU2Fuc1xcXCIsXFxcIkhpcmFnaW5vIEtha3UgR290aGljIFByb05cXFwiLFxcXCLjg5Ljg6njgq7jg47op5LjgrQgUHJvTiBXM1xcXCIsXFxcIuODoeOCpOODquOCqlxcXCIsTWVpcnlvLHNhbnMtc2VyaWY7XFxuICBjb2xvcjogIzMzMzsgfVxcbiAgYm9keSAqIHtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxcblxcbmxhYmVsIHtcXG4gIGRpc3BsYXk6IGJsb2NrOyB9XFxuXFxuLmNvbnRhaW5lciB7XFxuICBwYWRkaW5nOiA0MHB4IDAgMDtcXG4gIG1heC13aWR0aDogNjAwcHg7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG4gIG1hcmdpbi1yaWdodDogYXV0bzsgfVxcblxcbi5mb3JtLXdyYXBwZXIgPiAqICsgKiB7XFxuICBtYXJnaW4tdG9wOiAxOHB4OyB9XFxuXFxuLmZvcm0td3JhcHBlciArIC5mb3JtLXdyYXBwZXIge1xcbiAgbWFyZ2luLXRvcDogNDJweDsgfVxcblxcbi5idG4td3JhcCB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cXG5cXG4uYnRuLXdyYXAtcmlnaHQge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7IH1cXG5cXG4uYnRuIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJhY2tncm91bmQ6ICMwMDA7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHBhZGRpbmc6IDE2cHg7XFxuICBtaW4td2lkdGg6IDMwMHB4O1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgY29sb3I6ICNmZmY7XFxuICBmb250LXNpemU6IDE4cHg7IH1cXG4gIC5idG46ZGlzYWJsZWQge1xcbiAgICBvcGFjaXR5OiAwLjE7IH1cXG5cXG4uYnRuLXNlY29uZGFyeSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgYm9yZGVyOiAjZWVlIHNvbGlkIDJweDtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICBtaW4td2lkdGg6IDE2MHB4O1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgY29sb3I6ICMzMzM7XFxuICBmb250LXNpemU6IDE2cHg7IH1cXG4gIC5idG4tc2Vjb25kYXJ5OmRpc2FibGVkIHtcXG4gICAgb3BhY2l0eTogMC4xOyB9XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbaV0pO1xuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29udGFpbmVyXCIgfSwgW19jKFwicm91dGVyLXZpZXdcIildLCAxKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHsgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgdGhpcy4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290KSB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iLCIvKiFcbiAgKiB2dWUtcm91dGVyIHYzLjEuM1xuICAqIChjKSAyMDE5IEV2YW4gWW91XG4gICogQGxpY2Vuc2UgTUlUXG4gICovXG4vKiAgKi9cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybiAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25kaXRpb24pIHtcbiAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Vycm9yIChlcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpLmluZGV4T2YoJ0Vycm9yJykgPiAtMVxufVxuXG5mdW5jdGlvbiBpc0V4dGVuZGVkRXJyb3IgKGNvbnN0cnVjdG9yLCBlcnIpIHtcbiAgcmV0dXJuIChcbiAgICBlcnIgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvciB8fFxuICAgIC8vIF9uYW1lIGlzIHRvIHN1cHBvcnQgSUU5IHRvb1xuICAgIChlcnIgJiYgKGVyci5uYW1lID09PSBjb25zdHJ1Y3Rvci5uYW1lIHx8IGVyci5fbmFtZSA9PT0gY29uc3RydWN0b3IuX25hbWUpKVxuICApXG59XG5cbmZ1bmN0aW9uIGV4dGVuZCAoYSwgYikge1xuICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgIGFba2V5XSA9IGJba2V5XTtcbiAgfVxuICByZXR1cm4gYVxufVxuXG52YXIgVmlldyA9IHtcbiAgbmFtZTogJ1JvdXRlclZpZXcnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0J1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKF8sIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcblxuICAgIC8vIHVzZWQgYnkgZGV2dG9vbHMgdG8gZGlzcGxheSBhIHJvdXRlci12aWV3IGJhZGdlXG4gICAgZGF0YS5yb3V0ZXJWaWV3ID0gdHJ1ZTtcblxuICAgIC8vIGRpcmVjdGx5IHVzZSBwYXJlbnQgY29udGV4dCdzIGNyZWF0ZUVsZW1lbnQoKSBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgY29tcG9uZW50cyByZW5kZXJlZCBieSByb3V0ZXItdmlldyBjYW4gcmVzb2x2ZSBuYW1lZCBzbG90c1xuICAgIHZhciBoID0gcGFyZW50LiRjcmVhdGVFbGVtZW50O1xuICAgIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgICB2YXIgcm91dGUgPSBwYXJlbnQuJHJvdXRlO1xuICAgIHZhciBjYWNoZSA9IHBhcmVudC5fcm91dGVyVmlld0NhY2hlIHx8IChwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSA9IHt9KTtcblxuICAgIC8vIGRldGVybWluZSBjdXJyZW50IHZpZXcgZGVwdGgsIGFsc28gY2hlY2sgdG8gc2VlIGlmIHRoZSB0cmVlXG4gICAgLy8gaGFzIGJlZW4gdG9nZ2xlZCBpbmFjdGl2ZSBidXQga2VwdC1hbGl2ZS5cbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHZhciBpbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Ll9yb3V0ZXJSb290ICE9PSBwYXJlbnQpIHtcbiAgICAgIHZhciB2bm9kZURhdGEgPSBwYXJlbnQuJHZub2RlICYmIHBhcmVudC4kdm5vZGUuZGF0YTtcbiAgICAgIGlmICh2bm9kZURhdGEpIHtcbiAgICAgICAgaWYgKHZub2RlRGF0YS5yb3V0ZXJWaWV3KSB7XG4gICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGVEYXRhLmtlZXBBbGl2ZSAmJiBwYXJlbnQuX2luYWN0aXZlKSB7XG4gICAgICAgICAgaW5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgZGF0YS5yb3V0ZXJWaWV3RGVwdGggPSBkZXB0aDtcblxuICAgIC8vIHJlbmRlciBwcmV2aW91cyB2aWV3IGlmIHRoZSB0cmVlIGlzIGluYWN0aXZlIGFuZCBrZXB0LWFsaXZlXG4gICAgaWYgKGluYWN0aXZlKSB7XG4gICAgICByZXR1cm4gaChjYWNoZVtuYW1lXSwgZGF0YSwgY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZWQgPSByb3V0ZS5tYXRjaGVkW2RlcHRoXTtcbiAgICAvLyByZW5kZXIgZW1wdHkgbm9kZSBpZiBubyBtYXRjaGVkIHJvdXRlXG4gICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICBjYWNoZVtuYW1lXSA9IG51bGw7XG4gICAgICByZXR1cm4gaCgpXG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudCA9IGNhY2hlW25hbWVdID0gbWF0Y2hlZC5jb21wb25lbnRzW25hbWVdO1xuXG4gICAgLy8gYXR0YWNoIGluc3RhbmNlIHJlZ2lzdHJhdGlvbiBob29rXG4gICAgLy8gdGhpcyB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBpbmplY3RlZCBsaWZlY3ljbGUgaG9va3NcbiAgICBkYXRhLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgdmFsKSB7XG4gICAgICAvLyB2YWwgY291bGQgYmUgdW5kZWZpbmVkIGZvciB1bnJlZ2lzdHJhdGlvblxuICAgICAgdmFyIGN1cnJlbnQgPSBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgKHZhbCAmJiBjdXJyZW50ICE9PSB2bSkgfHxcbiAgICAgICAgKCF2YWwgJiYgY3VycmVudCA9PT0gdm0pXG4gICAgICApIHtcbiAgICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWxzbyByZWdpc3RlciBpbnN0YW5jZSBpbiBwcmVwYXRjaCBob29rXG4gICAgLy8gaW4gY2FzZSB0aGUgc2FtZSBjb21wb25lbnQgaW5zdGFuY2UgaXMgcmV1c2VkIGFjcm9zcyBkaWZmZXJlbnQgcm91dGVzXG4gICAgOyhkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KSkucHJlcGF0Y2ggPSBmdW5jdGlvbiAoXywgdm5vZGUpIHtcbiAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGluc3RhbmNlIGluIGluaXQgaG9va1xuICAgIC8vIGluIGNhc2Uga2VwdC1hbGl2ZSBjb21wb25lbnQgYmUgYWN0aXZlZCB3aGVuIHJvdXRlcyBjaGFuZ2VkXG4gICAgZGF0YS5ob29rLmluaXQgPSBmdW5jdGlvbiAodm5vZGUpIHtcbiAgICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSAmJlxuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAhPT0gbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV1cbiAgICAgICkge1xuICAgICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyByZXNvbHZlIHByb3BzXG4gICAgdmFyIHByb3BzVG9QYXNzID0gZGF0YS5wcm9wcyA9IHJlc29sdmVQcm9wcyhyb3V0ZSwgbWF0Y2hlZC5wcm9wcyAmJiBtYXRjaGVkLnByb3BzW25hbWVdKTtcbiAgICBpZiAocHJvcHNUb1Bhc3MpIHtcbiAgICAgIC8vIGNsb25lIHRvIHByZXZlbnQgbXV0YXRpb25cbiAgICAgIHByb3BzVG9QYXNzID0gZGF0YS5wcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHNUb1Bhc3MpO1xuICAgICAgLy8gcGFzcyBub24tZGVjbGFyZWQgcHJvcHMgYXMgYXR0cnNcbiAgICAgIHZhciBhdHRycyA9IGRhdGEuYXR0cnMgPSBkYXRhLmF0dHJzIHx8IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzVG9QYXNzKSB7XG4gICAgICAgIGlmICghY29tcG9uZW50LnByb3BzIHx8ICEoa2V5IGluIGNvbXBvbmVudC5wcm9wcykpIHtcbiAgICAgICAgICBhdHRyc1trZXldID0gcHJvcHNUb1Bhc3Nba2V5XTtcbiAgICAgICAgICBkZWxldGUgcHJvcHNUb1Bhc3Nba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoKGNvbXBvbmVudCwgZGF0YSwgY2hpbGRyZW4pXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVQcm9wcyAocm91dGUsIGNvbmZpZykge1xuICBzd2l0Y2ggKHR5cGVvZiBjb25maWcpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiBjb25maWdcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gY29uZmlnKHJvdXRlKVxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGNvbmZpZyA/IHJvdXRlLnBhcmFtcyA6IHVuZGVmaW5lZFxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwicHJvcHMgaW4gXFxcIlwiICsgKHJvdXRlLnBhdGgpICsgXCJcXFwiIGlzIGEgXCIgKyAodHlwZW9mIGNvbmZpZykgKyBcIiwgXCIgK1xuICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYm9vbGVhbi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZW5jb2RlUmVzZXJ2ZVJFID0gL1shJygpKl0vZztcbnZhciBlbmNvZGVSZXNlcnZlUmVwbGFjZXIgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTsgfTtcbnZhciBjb21tYVJFID0gLyUyQy9nO1xuXG4vLyBmaXhlZCBlbmNvZGVVUklDb21wb25lbnQgd2hpY2ggaXMgbW9yZSBjb25mb3JtYW50IHRvIFJGQzM5ODY6XG4vLyAtIGVzY2FwZXMgWyEnKCkqXVxuLy8gLSBwcmVzZXJ2ZSBjb21tYXNcbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKVxuICAucmVwbGFjZShlbmNvZGVSZXNlcnZlUkUsIGVuY29kZVJlc2VydmVSZXBsYWNlcilcbiAgLnJlcGxhY2UoY29tbWFSRSwgJywnKTsgfTtcblxudmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXJ5IChcbiAgcXVlcnksXG4gIGV4dHJhUXVlcnksXG4gIF9wYXJzZVF1ZXJ5XG4pIHtcbiAgaWYgKCBleHRyYVF1ZXJ5ID09PSB2b2lkIDAgKSBleHRyYVF1ZXJ5ID0ge307XG5cbiAgdmFyIHBhcnNlID0gX3BhcnNlUXVlcnkgfHwgcGFyc2VRdWVyeTtcbiAgdmFyIHBhcnNlZFF1ZXJ5O1xuICB0cnkge1xuICAgIHBhcnNlZFF1ZXJ5ID0gcGFyc2UocXVlcnkgfHwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBlLm1lc3NhZ2UpO1xuICAgIHBhcnNlZFF1ZXJ5ID0ge307XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIGV4dHJhUXVlcnkpIHtcbiAgICBwYXJzZWRRdWVyeVtrZXldID0gZXh0cmFRdWVyeVtrZXldO1xuICB9XG4gIHJldHVybiBwYXJzZWRRdWVyeVxufVxuXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5IChxdWVyeSkge1xuICB2YXIgcmVzID0ge307XG5cbiAgcXVlcnkgPSBxdWVyeS50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0cy5zaGlmdCgpKTtcbiAgICB2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMFxuICAgICAgPyBkZWNvZGUocGFydHMuam9pbignPScpKVxuICAgICAgOiBudWxsO1xuXG4gICAgaWYgKHJlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc1trZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXNba2V5XSkpIHtcbiAgICAgIHJlc1trZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2tleV0gPSBbcmVzW2tleV0sIHZhbF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5IChvYmopIHtcbiAgdmFyIHJlcyA9IG9iaiA/IE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoa2V5KVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG4gICAgICAgIGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsMiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwyKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsKVxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfSkuam9pbignJicpIDogbnVsbDtcbiAgcmV0dXJuIHJlcyA/IChcIj9cIiArIHJlcykgOiAnJ1xufVxuXG4vKiAgKi9cblxudmFyIHRyYWlsaW5nU2xhc2hSRSA9IC9cXC8/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlIChcbiAgcmVjb3JkLFxuICBsb2NhdGlvbixcbiAgcmVkaXJlY3RlZEZyb20sXG4gIHJvdXRlclxuKSB7XG4gIHZhciBzdHJpbmdpZnlRdWVyeSA9IHJvdXRlciAmJiByb3V0ZXIub3B0aW9ucy5zdHJpbmdpZnlRdWVyeTtcblxuICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeSB8fCB7fTtcbiAgdHJ5IHtcbiAgICBxdWVyeSA9IGNsb25lKHF1ZXJ5KTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcm91dGUgPSB7XG4gICAgbmFtZTogbG9jYXRpb24ubmFtZSB8fCAocmVjb3JkICYmIHJlY29yZC5uYW1lKSxcbiAgICBtZXRhOiAocmVjb3JkICYmIHJlY29yZC5tZXRhKSB8fCB7fSxcbiAgICBwYXRoOiBsb2NhdGlvbi5wYXRoIHx8ICcvJyxcbiAgICBoYXNoOiBsb2NhdGlvbi5oYXNoIHx8ICcnLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBwYXJhbXM6IGxvY2F0aW9uLnBhcmFtcyB8fCB7fSxcbiAgICBmdWxsUGF0aDogZ2V0RnVsbFBhdGgobG9jYXRpb24sIHN0cmluZ2lmeVF1ZXJ5KSxcbiAgICBtYXRjaGVkOiByZWNvcmQgPyBmb3JtYXRNYXRjaChyZWNvcmQpIDogW11cbiAgfTtcbiAgaWYgKHJlZGlyZWN0ZWRGcm9tKSB7XG4gICAgcm91dGUucmVkaXJlY3RlZEZyb20gPSBnZXRGdWxsUGF0aChyZWRpcmVjdGVkRnJvbSwgc3RyaW5naWZ5UXVlcnkpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHJvdXRlKVxufVxuXG5mdW5jdGlvbiBjbG9uZSAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcChjbG9uZSlcbiAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgcmVzW2tleV0gPSBjbG9uZSh2YWx1ZVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG5cbi8vIHRoZSBzdGFydGluZyByb3V0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGluaXRpYWwgc3RhdGVcbnZhciBTVEFSVCA9IGNyZWF0ZVJvdXRlKG51bGwsIHtcbiAgcGF0aDogJy8nXG59KTtcblxuZnVuY3Rpb24gZm9ybWF0TWF0Y2ggKHJlY29yZCkge1xuICB2YXIgcmVzID0gW107XG4gIHdoaWxlIChyZWNvcmQpIHtcbiAgICByZXMudW5zaGlmdChyZWNvcmQpO1xuICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRGdWxsUGF0aCAoXG4gIHJlZixcbiAgX3N0cmluZ2lmeVF1ZXJ5XG4pIHtcbiAgdmFyIHBhdGggPSByZWYucGF0aDtcbiAgdmFyIHF1ZXJ5ID0gcmVmLnF1ZXJ5OyBpZiAoIHF1ZXJ5ID09PSB2b2lkIDAgKSBxdWVyeSA9IHt9O1xuICB2YXIgaGFzaCA9IHJlZi5oYXNoOyBpZiAoIGhhc2ggPT09IHZvaWQgMCApIGhhc2ggPSAnJztcblxuICB2YXIgc3RyaW5naWZ5ID0gX3N0cmluZ2lmeVF1ZXJ5IHx8IHN0cmluZ2lmeVF1ZXJ5O1xuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHN0cmluZ2lmeShxdWVyeSkgKyBoYXNoXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVJvdXRlIChhLCBiKSB7XG4gIGlmIChiID09PSBTVEFSVCkge1xuICAgIHJldHVybiBhID09PSBiXG4gIH0gZWxzZSBpZiAoIWIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChhLnBhdGggJiYgYi5wYXRoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpID09PSBiLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSlcbiAgICApXG4gIH0gZWxzZSBpZiAoYS5uYW1lICYmIGIubmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICBhLm5hbWUgPT09IGIubmFtZSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSkgJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5wYXJhbXMsIGIucGFyYW1zKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpc09iamVjdEVxdWFsIChhLCBiKSB7XG4gIGlmICggYSA9PT0gdm9pZCAwICkgYSA9IHt9O1xuICBpZiAoIGIgPT09IHZvaWQgMCApIGIgPSB7fTtcblxuICAvLyBoYW5kbGUgbnVsbCB2YWx1ZSAjMTU2NlxuICBpZiAoIWEgfHwgIWIpIHsgcmV0dXJuIGEgPT09IGIgfVxuICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGFWYWwgPSBhW2tleV07XG4gICAgdmFyIGJWYWwgPSBiW2tleV07XG4gICAgLy8gY2hlY2sgbmVzdGVkIGVxdWFsaXR5XG4gICAgaWYgKHR5cGVvZiBhVmFsID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYlZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBpc09iamVjdEVxdWFsKGFWYWwsIGJWYWwpXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYVZhbCkgPT09IFN0cmluZyhiVmFsKVxuICB9KVxufVxuXG5mdW5jdGlvbiBpc0luY2x1ZGVkUm91dGUgKGN1cnJlbnQsIHRhcmdldCkge1xuICByZXR1cm4gKFxuICAgIGN1cnJlbnQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKS5pbmRleE9mKFxuICAgICAgdGFyZ2V0LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJylcbiAgICApID09PSAwICYmXG4gICAgKCF0YXJnZXQuaGFzaCB8fCBjdXJyZW50Lmhhc2ggPT09IHRhcmdldC5oYXNoKSAmJlxuICAgIHF1ZXJ5SW5jbHVkZXMoY3VycmVudC5xdWVyeSwgdGFyZ2V0LnF1ZXJ5KVxuICApXG59XG5cbmZ1bmN0aW9uIHF1ZXJ5SW5jbHVkZXMgKGN1cnJlbnQsIHRhcmdldCkge1xuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgaWYgKCEoa2V5IGluIGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRoIChcbiAgcmVsYXRpdmUsXG4gIGJhc2UsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBmaXJzdENoYXIgPSByZWxhdGl2ZS5jaGFyQXQoMCk7XG4gIGlmIChmaXJzdENoYXIgPT09ICcvJykge1xuICAgIHJldHVybiByZWxhdGl2ZVxuICB9XG5cbiAgaWYgKGZpcnN0Q2hhciA9PT0gJz8nIHx8IGZpcnN0Q2hhciA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIGJhc2UgKyByZWxhdGl2ZVxuICB9XG5cbiAgdmFyIHN0YWNrID0gYmFzZS5zcGxpdCgnLycpO1xuXG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzZWdtZW50IGlmOlxuICAvLyAtIG5vdCBhcHBlbmRpbmdcbiAgLy8gLSBhcHBlbmRpbmcgdG8gdHJhaWxpbmcgc2xhc2ggKGxhc3Qgc2VnbWVudCBpcyBlbXB0eSlcbiAgaWYgKCFhcHBlbmQgfHwgIXN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICAvLyByZXNvbHZlIHJlbGF0aXZlIHBhdGhcbiAgdmFyIHNlZ21lbnRzID0gcmVsYXRpdmUucmVwbGFjZSgvXlxcLy8sICcnKS5zcGxpdCgnLycpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSAnLicpIHtcbiAgICAgIHN0YWNrLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5zdXJlIGxlYWRpbmcgc2xhc2hcbiAgaWYgKHN0YWNrWzBdICE9PSAnJykge1xuICAgIHN0YWNrLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrLmpvaW4oJy8nKVxufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgdmFyIGhhc2ggPSAnJztcbiAgdmFyIHF1ZXJ5ID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICBoYXNoID0gcGF0aC5zbGljZShoYXNoSW5kZXgpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuICBpZiAocXVlcnlJbmRleCA+PSAwKSB7XG4gICAgcXVlcnkgPSBwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxKTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBxdWVyeUluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgaGFzaDogaGFzaFxuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuUGF0aCAocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC9cXC8vZywgJy8nKVxufVxuXG52YXIgaXNhcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG52YXIgcGF0aFRvUmVnZXhwXzEgPSBwYXRoVG9SZWdleHA7XG52YXIgcGFyc2VfMSA9IHBhcnNlO1xudmFyIGNvbXBpbGVfMSA9IGNvbXBpbGU7XG52YXIgdG9rZW5zVG9GdW5jdGlvbl8xID0gdG9rZW5zVG9GdW5jdGlvbjtcbnZhciB0b2tlbnNUb1JlZ0V4cF8xID0gdG9rZW5zVG9SZWdFeHA7XG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGtleSA9IDA7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBwYXRoID0gJyc7XG4gIHZhciBkZWZhdWx0RGVsaW1pdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlciB8fCAnLyc7XG4gIHZhciByZXM7XG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXTtcbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXTtcbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4O1xuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpO1xuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGg7XG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF07XG4gICAgdmFyIHByZWZpeCA9IHJlc1syXTtcbiAgICB2YXIgbmFtZSA9IHJlc1szXTtcbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XTtcbiAgICB2YXIgZ3JvdXAgPSByZXNbNV07XG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdO1xuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XTtcblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpO1xuICAgICAgcGF0aCA9ICcnO1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeDtcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonO1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXI7XG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwO1xuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleCk7XG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBleGlzdHMsIHB1c2ggaXQgb250byB0aGUgZW5kLlxuICBpZiAocGF0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpO1xuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJztcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlbjtcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdO1xuICAgICAgdmFyIHNlZ21lbnQ7XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSk7XG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXM7XG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBhc3RlcmlzazogZmFsc2UsXG4gICAgICAgIHBhdHRlcm46IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKTtcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZTtcbiAgdmFyIHJvdXRlID0gJyc7XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpO1xuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSc7XG5cbiAgICAgIGtleXMucHVzaCh0b2tlbik7XG5cbiAgICAgIGlmICh0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/JztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpO1xuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlcjtcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/JztcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCc7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJztcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGlzYXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG5wYXRoVG9SZWdleHBfMS5wYXJzZSA9IHBhcnNlXzE7XG5wYXRoVG9SZWdleHBfMS5jb21waWxlID0gY29tcGlsZV8xO1xucGF0aFRvUmVnZXhwXzEudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25fMTtcbnBhdGhUb1JlZ2V4cF8xLnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBfMTtcblxuLyogICovXG5cbi8vICRmbG93LWRpc2FibGUtbGluZVxudmFyIHJlZ2V4cENvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGZpbGxQYXJhbXMgKFxuICBwYXRoLFxuICBwYXJhbXMsXG4gIHJvdXRlTXNnXG4pIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICB0cnkge1xuICAgIHZhciBmaWxsZXIgPVxuICAgICAgcmVnZXhwQ29tcGlsZUNhY2hlW3BhdGhdIHx8XG4gICAgICAocmVnZXhwQ29tcGlsZUNhY2hlW3BhdGhdID0gcGF0aFRvUmVnZXhwXzEuY29tcGlsZShwYXRoKSk7XG5cbiAgICAvLyBGaXggIzI1MDUgcmVzb2x2aW5nIGFzdGVyaXNrIHJvdXRlcyB7IG5hbWU6ICdub3QtZm91bmQnLCBwYXJhbXM6IHsgcGF0aE1hdGNoOiAnL25vdC1mb3VuZCcgfX1cbiAgICBpZiAocGFyYW1zLnBhdGhNYXRjaCkgeyBwYXJhbXNbMF0gPSBwYXJhbXMucGF0aE1hdGNoOyB9XG5cbiAgICByZXR1cm4gZmlsbGVyKHBhcmFtcywgeyBwcmV0dHk6IHRydWUgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCAoXCJtaXNzaW5nIHBhcmFtIGZvciBcIiArIHJvdXRlTXNnICsgXCI6IFwiICsgKGUubWVzc2FnZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH0gZmluYWxseSB7XG4gICAgLy8gZGVsZXRlIHRoZSAwIGlmIGl0IHdhcyBhZGRlZFxuICAgIGRlbGV0ZSBwYXJhbXNbMF07XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICBhcHBlbmQsXG4gIHJvdXRlclxuKSB7XG4gIHZhciBuZXh0ID0gdHlwZW9mIHJhdyA9PT0gJ3N0cmluZycgPyB7IHBhdGg6IHJhdyB9IDogcmF3O1xuICAvLyBuYW1lZCB0YXJnZXRcbiAgaWYgKG5leHQuX25vcm1hbGl6ZWQpIHtcbiAgICByZXR1cm4gbmV4dFxuICB9IGVsc2UgaWYgKG5leHQubmFtZSkge1xuICAgIHJldHVybiBleHRlbmQoe30sIHJhdylcbiAgfVxuXG4gIC8vIHJlbGF0aXZlIHBhcmFtc1xuICBpZiAoIW5leHQucGF0aCAmJiBuZXh0LnBhcmFtcyAmJiBjdXJyZW50KSB7XG4gICAgbmV4dCA9IGV4dGVuZCh7fSwgbmV4dCk7XG4gICAgbmV4dC5fbm9ybWFsaXplZCA9IHRydWU7XG4gICAgdmFyIHBhcmFtcyA9IGV4dGVuZChleHRlbmQoe30sIGN1cnJlbnQucGFyYW1zKSwgbmV4dC5wYXJhbXMpO1xuICAgIGlmIChjdXJyZW50Lm5hbWUpIHtcbiAgICAgIG5leHQubmFtZSA9IGN1cnJlbnQubmFtZTtcbiAgICAgIG5leHQucGFyYW1zID0gcGFyYW1zO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5tYXRjaGVkLmxlbmd0aCkge1xuICAgICAgdmFyIHJhd1BhdGggPSBjdXJyZW50Lm1hdGNoZWRbY3VycmVudC5tYXRjaGVkLmxlbmd0aCAtIDFdLnBhdGg7XG4gICAgICBuZXh0LnBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicGF0aCBcIiArIChjdXJyZW50LnBhdGgpKSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCBcInJlbGF0aXZlIHBhcmFtcyBuYXZpZ2F0aW9uIHJlcXVpcmVzIGEgY3VycmVudCByb3V0ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICB2YXIgcGFyc2VkUGF0aCA9IHBhcnNlUGF0aChuZXh0LnBhdGggfHwgJycpO1xuICB2YXIgYmFzZVBhdGggPSAoY3VycmVudCAmJiBjdXJyZW50LnBhdGgpIHx8ICcvJztcbiAgdmFyIHBhdGggPSBwYXJzZWRQYXRoLnBhdGhcbiAgICA/IHJlc29sdmVQYXRoKHBhcnNlZFBhdGgucGF0aCwgYmFzZVBhdGgsIGFwcGVuZCB8fCBuZXh0LmFwcGVuZClcbiAgICA6IGJhc2VQYXRoO1xuXG4gIHZhciBxdWVyeSA9IHJlc29sdmVRdWVyeShcbiAgICBwYXJzZWRQYXRoLnF1ZXJ5LFxuICAgIG5leHQucXVlcnksXG4gICAgcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnBhcnNlUXVlcnlcbiAgKTtcblxuICB2YXIgaGFzaCA9IG5leHQuaGFzaCB8fCBwYXJzZWRQYXRoLmhhc2g7XG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHtcbiAgICBoYXNoID0gXCIjXCIgKyBoYXNoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuLyogICovXG5cbi8vIHdvcmsgYXJvdW5kIHdlaXJkIGZsb3cgYnVnXG52YXIgdG9UeXBlcyA9IFtTdHJpbmcsIE9iamVjdF07XG52YXIgZXZlbnRUeXBlcyA9IFtTdHJpbmcsIEFycmF5XTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIExpbmsgPSB7XG4gIG5hbWU6ICdSb3V0ZXJMaW5rJyxcbiAgcHJvcHM6IHtcbiAgICB0bzoge1xuICAgICAgdHlwZTogdG9UeXBlcyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdhJ1xuICAgIH0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IGV2ZW50VHlwZXMsXG4gICAgICBkZWZhdWx0OiAnY2xpY2snXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMuJHJvdXRlcjtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuJHJvdXRlO1xuICAgIHZhciByZWYgPSByb3V0ZXIucmVzb2x2ZShcbiAgICAgIHRoaXMudG8sXG4gICAgICBjdXJyZW50LFxuICAgICAgdGhpcy5hcHBlbmRcbiAgICApO1xuICAgIHZhciBsb2NhdGlvbiA9IHJlZi5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGUgPSByZWYucm91dGU7XG4gICAgdmFyIGhyZWYgPSByZWYuaHJlZjtcblxuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgdmFyIGdsb2JhbEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzO1xuICAgIHZhciBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0V4YWN0QWN0aXZlQ2xhc3M7XG4gICAgLy8gU3VwcG9ydCBnbG9iYWwgZW1wdHkgYWN0aXZlIGNsYXNzXG4gICAgdmFyIGFjdGl2ZUNsYXNzRmFsbGJhY2sgPVxuICAgICAgZ2xvYmFsQWN0aXZlQ2xhc3MgPT0gbnVsbCA/ICdyb3V0ZXItbGluay1hY3RpdmUnIDogZ2xvYmFsQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayA9XG4gICAgICBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgPyAncm91dGVyLWxpbmstZXhhY3QtYWN0aXZlJ1xuICAgICAgICA6IGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3M7XG4gICAgdmFyIGFjdGl2ZUNsYXNzID1cbiAgICAgIHRoaXMuYWN0aXZlQ2xhc3MgPT0gbnVsbCA/IGFjdGl2ZUNsYXNzRmFsbGJhY2sgOiB0aGlzLmFjdGl2ZUNsYXNzO1xuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzID1cbiAgICAgIHRoaXMuZXhhY3RBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgID8gZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrXG4gICAgICAgIDogdGhpcy5leGFjdEFjdGl2ZUNsYXNzO1xuXG4gICAgdmFyIGNvbXBhcmVUYXJnZXQgPSByb3V0ZS5yZWRpcmVjdGVkRnJvbVxuICAgICAgPyBjcmVhdGVSb3V0ZShudWxsLCBub3JtYWxpemVMb2NhdGlvbihyb3V0ZS5yZWRpcmVjdGVkRnJvbSksIG51bGwsIHJvdXRlcilcbiAgICAgIDogcm91dGU7XG5cbiAgICBjbGFzc2VzW2V4YWN0QWN0aXZlQ2xhc3NdID0gaXNTYW1lUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XG4gICAgY2xhc3Nlc1thY3RpdmVDbGFzc10gPSB0aGlzLmV4YWN0XG4gICAgICA/IGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc11cbiAgICAgIDogaXNJbmNsdWRlZFJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGd1YXJkRXZlbnQoZSkpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5yZXBsYWNlKSB7XG4gICAgICAgICAgcm91dGVyLnJlcGxhY2UobG9jYXRpb24sIG5vb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlci5wdXNoKGxvY2F0aW9uLCBub29wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb24gPSB7IGNsaWNrOiBndWFyZEV2ZW50IH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnQuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICBvbltlXSA9IGhhbmRsZXI7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25bdGhpcy5ldmVudF0gPSBoYW5kbGVyO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0geyBjbGFzczogY2xhc3NlcyB9O1xuXG4gICAgdmFyIHNjb3BlZFNsb3QgPVxuICAgICAgIXRoaXMuJHNjb3BlZFNsb3RzLiRoYXNOb3JtYWwgJiZcbiAgICAgIHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQgJiZcbiAgICAgIHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQoe1xuICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICByb3V0ZTogcm91dGUsXG4gICAgICAgIG5hdmlnYXRlOiBoYW5kbGVyLFxuICAgICAgICBpc0FjdGl2ZTogY2xhc3Nlc1thY3RpdmVDbGFzc10sXG4gICAgICAgIGlzRXhhY3RBY3RpdmU6IGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc11cbiAgICAgIH0pO1xuXG4gICAgaWYgKHNjb3BlZFNsb3QpIHtcbiAgICAgIGlmIChzY29wZWRTbG90Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2NvcGVkU2xvdFswXVxuICAgICAgfSBlbHNlIGlmIChzY29wZWRTbG90Lmxlbmd0aCA+IDEgfHwgIXNjb3BlZFNsb3QubGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgKFwiUm91dGVyTGluayB3aXRoIHRvPVxcXCJcIiArICh0aGlzLnByb3BzLnRvKSArIFwiXFxcIiBpcyB0cnlpbmcgdG8gdXNlIGEgc2NvcGVkIHNsb3QgYnV0IGl0IGRpZG4ndCBwcm92aWRlIGV4YWN0bHkgb25lIGNoaWxkLlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlZFNsb3QubGVuZ3RoID09PSAwID8gaCgpIDogaCgnc3BhbicsIHt9LCBzY29wZWRTbG90KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRhZyA9PT0gJ2EnKSB7XG4gICAgICBkYXRhLm9uID0gb247XG4gICAgICBkYXRhLmF0dHJzID0geyBocmVmOiBocmVmIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IDxhPiBjaGlsZCBhbmQgYXBwbHkgbGlzdGVuZXIgYW5kIGhyZWZcbiAgICAgIHZhciBhID0gZmluZEFuY2hvcih0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIDxhPiBpcyBhIHN0YXRpYyBub2RlXG4gICAgICAgIGEuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFEYXRhID0gKGEuZGF0YSA9IGV4dGVuZCh7fSwgYS5kYXRhKSk7XG4gICAgICAgIGFEYXRhLm9uID0gYURhdGEub24gfHwge307XG4gICAgICAgIC8vIHRyYW5zZm9ybSBleGlzdGluZyBldmVudHMgaW4gYm90aCBvYmplY3RzIGludG8gYXJyYXlzIHNvIHdlIGNhbiBwdXNoIGxhdGVyXG4gICAgICAgIGZvciAodmFyIGV2ZW50IGluIGFEYXRhLm9uKSB7XG4gICAgICAgICAgdmFyIGhhbmRsZXIkMSA9IGFEYXRhLm9uW2V2ZW50XTtcbiAgICAgICAgICBpZiAoZXZlbnQgaW4gb24pIHtcbiAgICAgICAgICAgIGFEYXRhLm9uW2V2ZW50XSA9IEFycmF5LmlzQXJyYXkoaGFuZGxlciQxKSA/IGhhbmRsZXIkMSA6IFtoYW5kbGVyJDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBlbmQgbmV3IGxpc3RlbmVycyBmb3Igcm91dGVyLWxpbmtcbiAgICAgICAgZm9yICh2YXIgZXZlbnQkMSBpbiBvbikge1xuICAgICAgICAgIGlmIChldmVudCQxIGluIGFEYXRhLm9uKSB7XG4gICAgICAgICAgICAvLyBvbltldmVudF0gaXMgYWx3YXlzIGEgZnVuY3Rpb25cbiAgICAgICAgICAgIGFEYXRhLm9uW2V2ZW50JDFdLnB1c2gob25bZXZlbnQkMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhRGF0YS5vbltldmVudCQxXSA9IGhhbmRsZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFBdHRycyA9IChhLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGEuZGF0YS5hdHRycykpO1xuICAgICAgICBhQXR0cnMuaHJlZiA9IGhyZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb2Vzbid0IGhhdmUgPGE+IGNoaWxkLCBhcHBseSBsaXN0ZW5lciB0byBzZWxmXG4gICAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaCh0aGlzLnRhZywgZGF0YSwgdGhpcy4kc2xvdHMuZGVmYXVsdClcbiAgfVxufTtcblxuZnVuY3Rpb24gZ3VhcmRFdmVudCAoZSkge1xuICAvLyBkb24ndCByZWRpcmVjdCB3aXRoIGNvbnRyb2wga2V5c1xuICBpZiAoZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcbiAgaWYgKGUuYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b24gIT09IDApIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3QgaWYgYHRhcmdldD1cIl9ibGFua1wiYFxuICBpZiAoZS5jdXJyZW50VGFyZ2V0ICYmIGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgaWYgKC9cXGJfYmxhbmtcXGIvaS50ZXN0KHRhcmdldCkpIHsgcmV0dXJuIH1cbiAgfVxuICAvLyB0aGlzIG1heSBiZSBhIFdlZXggZXZlbnQgd2hpY2ggZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kXG4gIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbmRBbmNob3IgKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIHZhciBjaGlsZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ2EnKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuICYmIChjaGlsZCA9IGZpbmRBbmNob3IoY2hpbGQuY2hpbGRyZW4pKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIF9WdWU7XG5cbmZ1bmN0aW9uIGluc3RhbGwgKFZ1ZSkge1xuICBpZiAoaW5zdGFsbC5pbnN0YWxsZWQgJiYgX1Z1ZSA9PT0gVnVlKSB7IHJldHVybiB9XG4gIGluc3RhbGwuaW5zdGFsbGVkID0gdHJ1ZTtcblxuICBfVnVlID0gVnVlO1xuXG4gIHZhciBpc0RlZiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH07XG5cbiAgdmFyIHJlZ2lzdGVySW5zdGFuY2UgPSBmdW5jdGlvbiAodm0sIGNhbGxWYWwpIHtcbiAgICB2YXIgaSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgICBpZiAoaXNEZWYoaSkgJiYgaXNEZWYoaSA9IGkuZGF0YSkgJiYgaXNEZWYoaSA9IGkucmVnaXN0ZXJSb3V0ZUluc3RhbmNlKSkge1xuICAgICAgaSh2bSwgY2FsbFZhbCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5taXhpbih7XG4gICAgYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiBiZWZvcmVDcmVhdGUgKCkge1xuICAgICAgaWYgKGlzRGVmKHRoaXMuJG9wdGlvbnMucm91dGVyKSkge1xuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gdGhpcztcbiAgICAgICAgdGhpcy5fcm91dGVyID0gdGhpcy4kb3B0aW9ucy5yb3V0ZXI7XG4gICAgICAgIHRoaXMuX3JvdXRlci5pbml0KHRoaXMpO1xuICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLCAnX3JvdXRlJywgdGhpcy5fcm91dGVyLmhpc3RvcnkuY3VycmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gKHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuX3JvdXRlclJvb3QpIHx8IHRoaXM7XG4gICAgICB9XG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIHRoaXMpO1xuICAgIH0sXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlcicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZXIgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZSB9XG4gIH0pO1xuXG4gIFZ1ZS5jb21wb25lbnQoJ1JvdXRlclZpZXcnLCBWaWV3KTtcbiAgVnVlLmNvbXBvbmVudCgnUm91dGVyTGluaycsIExpbmspO1xuXG4gIHZhciBzdHJhdHMgPSBWdWUuY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcbiAgLy8gdXNlIHRoZSBzYW1lIGhvb2sgbWVyZ2luZyBzdHJhdGVneSBmb3Igcm91dGUgaG9va3NcbiAgc3RyYXRzLmJlZm9yZVJvdXRlRW50ZXIgPSBzdHJhdHMuYmVmb3JlUm91dGVMZWF2ZSA9IHN0cmF0cy5iZWZvcmVSb3V0ZVVwZGF0ZSA9IHN0cmF0cy5jcmVhdGVkO1xufVxuXG4vKiAgKi9cblxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVNYXAgKFxuICByb3V0ZXMsXG4gIG9sZFBhdGhMaXN0LFxuICBvbGRQYXRoTWFwLFxuICBvbGROYW1lTWFwXG4pIHtcbiAgLy8gdGhlIHBhdGggbGlzdCBpcyB1c2VkIHRvIGNvbnRyb2wgcGF0aCBtYXRjaGluZyBwcmlvcml0eVxuICB2YXIgcGF0aExpc3QgPSBvbGRQYXRoTGlzdCB8fCBbXTtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciBwYXRoTWFwID0gb2xkUGF0aE1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIG5hbWVNYXAgPSBvbGROYW1lTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcm91dGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIHJvdXRlKTtcbiAgfSk7XG5cbiAgLy8gZW5zdXJlIHdpbGRjYXJkIHJvdXRlcyBhcmUgYWx3YXlzIGF0IHRoZSBlbmRcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAocGF0aExpc3RbaV0gPT09ICcqJykge1xuICAgICAgcGF0aExpc3QucHVzaChwYXRoTGlzdC5zcGxpY2UoaSwgMSlbMF0pO1xuICAgICAgbC0tO1xuICAgICAgaS0tO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIC8vIHdhcm4gaWYgcm91dGVzIGRvIG5vdCBpbmNsdWRlIGxlYWRpbmcgc2xhc2hlc1xuICAgIHZhciBmb3VuZCA9IHBhdGhMaXN0XG4gICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgbGVhZGluZyBzbGFzaFxuICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aCAmJiBwYXRoLmNoYXJBdCgwKSAhPT0gJyonICYmIHBhdGguY2hhckF0KDApICE9PSAnLyc7IH0pO1xuXG4gICAgaWYgKGZvdW5kLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBwYXRoTmFtZXMgPSBmb3VuZC5tYXAoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIChcIi0gXCIgKyBwYXRoKTsgfSkuam9pbignXFxuJyk7XG4gICAgICB3YXJuKGZhbHNlLCAoXCJOb24tbmVzdGVkIHJvdXRlcyBtdXN0IGluY2x1ZGUgYSBsZWFkaW5nIHNsYXNoIGNoYXJhY3Rlci4gRml4IHRoZSBmb2xsb3dpbmcgcm91dGVzOiBcXG5cIiArIHBhdGhOYW1lcykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aExpc3Q6IHBhdGhMaXN0LFxuICAgIHBhdGhNYXA6IHBhdGhNYXAsXG4gICAgbmFtZU1hcDogbmFtZU1hcFxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJvdXRlUmVjb3JkIChcbiAgcGF0aExpc3QsXG4gIHBhdGhNYXAsXG4gIG5hbWVNYXAsXG4gIHJvdXRlLFxuICBwYXJlbnQsXG4gIG1hdGNoQXNcbikge1xuICB2YXIgcGF0aCA9IHJvdXRlLnBhdGg7XG4gIHZhciBuYW1lID0gcm91dGUubmFtZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQocGF0aCAhPSBudWxsLCBcIlxcXCJwYXRoXFxcIiBpcyByZXF1aXJlZCBpbiBhIHJvdXRlIGNvbmZpZ3VyYXRpb24uXCIpO1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiByb3V0ZS5jb21wb25lbnQgIT09ICdzdHJpbmcnLFxuICAgICAgXCJyb3V0ZSBjb25maWcgXFxcImNvbXBvbmVudFxcXCIgZm9yIHBhdGg6IFwiICsgKFN0cmluZyhcbiAgICAgICAgcGF0aCB8fCBuYW1lXG4gICAgICApKSArIFwiIGNhbm5vdCBiZSBhIFwiICsgXCJzdHJpbmcgaWQuIFVzZSBhbiBhY3R1YWwgY29tcG9uZW50IGluc3RlYWQuXCJcbiAgICApO1xuICB9XG5cbiAgdmFyIHBhdGhUb1JlZ2V4cE9wdGlvbnMgPVxuICAgIHJvdXRlLnBhdGhUb1JlZ2V4cE9wdGlvbnMgfHwge307XG4gIHZhciBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCwgcGFyZW50LCBwYXRoVG9SZWdleHBPcHRpb25zLnN0cmljdCk7XG5cbiAgaWYgKHR5cGVvZiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSAnYm9vbGVhbicpIHtcbiAgICBwYXRoVG9SZWdleHBPcHRpb25zLnNlbnNpdGl2ZSA9IHJvdXRlLmNhc2VTZW5zaXRpdmU7XG4gIH1cblxuICB2YXIgcmVjb3JkID0ge1xuICAgIHBhdGg6IG5vcm1hbGl6ZWRQYXRoLFxuICAgIHJlZ2V4OiBjb21waWxlUm91dGVSZWdleChub3JtYWxpemVkUGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucyksXG4gICAgY29tcG9uZW50czogcm91dGUuY29tcG9uZW50cyB8fCB7IGRlZmF1bHQ6IHJvdXRlLmNvbXBvbmVudCB9LFxuICAgIGluc3RhbmNlczoge30sXG4gICAgbmFtZTogbmFtZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBtYXRjaEFzOiBtYXRjaEFzLFxuICAgIHJlZGlyZWN0OiByb3V0ZS5yZWRpcmVjdCxcbiAgICBiZWZvcmVFbnRlcjogcm91dGUuYmVmb3JlRW50ZXIsXG4gICAgbWV0YTogcm91dGUubWV0YSB8fCB7fSxcbiAgICBwcm9wczpcbiAgICAgIHJvdXRlLnByb3BzID09IG51bGxcbiAgICAgICAgPyB7fVxuICAgICAgICA6IHJvdXRlLmNvbXBvbmVudHNcbiAgICAgICAgICA/IHJvdXRlLnByb3BzXG4gICAgICAgICAgOiB7IGRlZmF1bHQ6IHJvdXRlLnByb3BzIH1cbiAgfTtcblxuICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAvLyBXYXJuIGlmIHJvdXRlIGlzIG5hbWVkLCBkb2VzIG5vdCByZWRpcmVjdCBhbmQgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS5cbiAgICAvLyBJZiB1c2VycyBuYXZpZ2F0ZSB0byB0aGlzIHJvdXRlIGJ5IG5hbWUsIHRoZSBkZWZhdWx0IGNoaWxkIHdpbGxcbiAgICAvLyBub3QgYmUgcmVuZGVyZWQgKEdIIElzc3VlICM2MjkpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcm91dGUubmFtZSAmJlxuICAgICAgICAhcm91dGUucmVkaXJlY3QgJiZcbiAgICAgICAgcm91dGUuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIC9eXFwvPyQvLnRlc3QoY2hpbGQucGF0aCk7IH0pXG4gICAgICApIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIk5hbWVkIFJvdXRlICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJyBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLiBcIiArXG4gICAgICAgICAgICBcIldoZW4gbmF2aWdhdGluZyB0byB0aGlzIG5hbWVkIHJvdXRlICg6dG89XFxcIntuYW1lOiAnXCIgKyAocm91dGUubmFtZSkgKyBcIidcXFwiKSwgXCIgK1xuICAgICAgICAgICAgXCJ0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSB3aWxsIG5vdCBiZSByZW5kZXJlZC4gUmVtb3ZlIHRoZSBuYW1lIGZyb20gXCIgK1xuICAgICAgICAgICAgXCJ0aGlzIHJvdXRlIGFuZCB1c2UgdGhlIG5hbWUgb2YgdGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgZm9yIG5hbWVkIFwiICtcbiAgICAgICAgICAgIFwibGlua3MgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTWF0Y2hBcyA9IG1hdGNoQXNcbiAgICAgICAgPyBjbGVhblBhdGgoKG1hdGNoQXMgKyBcIi9cIiArIChjaGlsZC5wYXRoKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIGNoaWxkLCByZWNvcmQsIGNoaWxkTWF0Y2hBcyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIXBhdGhNYXBbcmVjb3JkLnBhdGhdKSB7XG4gICAgcGF0aExpc3QucHVzaChyZWNvcmQucGF0aCk7XG4gICAgcGF0aE1hcFtyZWNvcmQucGF0aF0gPSByZWNvcmQ7XG4gIH1cblxuICBpZiAocm91dGUuYWxpYXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBhbGlhc2VzID0gQXJyYXkuaXNBcnJheShyb3V0ZS5hbGlhcykgPyByb3V0ZS5hbGlhcyA6IFtyb3V0ZS5hbGlhc107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGlhc2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYWxpYXMgPSBhbGlhc2VzW2ldO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYWxpYXMgPT09IHBhdGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAoXCJGb3VuZCBhbiBhbGlhcyB3aXRoIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBwYXRoOiBcXFwiXCIgKyBwYXRoICsgXCJcXFwiLiBZb3UgaGF2ZSB0byByZW1vdmUgdGhhdCBhbGlhcy4gSXQgd2lsbCBiZSBpZ25vcmVkIGluIGRldmVsb3BtZW50LlwiKVxuICAgICAgICApO1xuICAgICAgICAvLyBza2lwIGluIGRldiB0byBtYWtlIGl0IHdvcmtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIGFsaWFzUm91dGUgPSB7XG4gICAgICAgIHBhdGg6IGFsaWFzLFxuICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW5cbiAgICAgIH07XG4gICAgICBhZGRSb3V0ZVJlY29yZChcbiAgICAgICAgcGF0aExpc3QsXG4gICAgICAgIHBhdGhNYXAsXG4gICAgICAgIG5hbWVNYXAsXG4gICAgICAgIGFsaWFzUm91dGUsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcmVjb3JkLnBhdGggfHwgJy8nIC8vIG1hdGNoQXNcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5hbWUpIHtcbiAgICBpZiAoIW5hbWVNYXBbbmFtZV0pIHtcbiAgICAgIG5hbWVNYXBbbmFtZV0gPSByZWNvcmQ7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFtYXRjaEFzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJEdXBsaWNhdGUgbmFtZWQgcm91dGVzIGRlZmluaXRpb246IFwiICtcbiAgICAgICAgICBcInsgbmFtZTogXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgcGF0aDogXFxcIlwiICsgKHJlY29yZC5wYXRoKSArIFwiXFxcIiB9XCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVSb3V0ZVJlZ2V4IChcbiAgcGF0aCxcbiAgcGF0aFRvUmVnZXhwT3B0aW9uc1xuKSB7XG4gIHZhciByZWdleCA9IHBhdGhUb1JlZ2V4cF8xKHBhdGgsIFtdLCBwYXRoVG9SZWdleHBPcHRpb25zKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmVnZXgua2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICFrZXlzW2tleS5uYW1lXSxcbiAgICAgICAgKFwiRHVwbGljYXRlIHBhcmFtIGtleXMgaW4gcm91dGUgd2l0aCBwYXRoOiBcXFwiXCIgKyBwYXRoICsgXCJcXFwiXCIpXG4gICAgICApO1xuICAgICAga2V5c1trZXkubmFtZV0gPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZWdleFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoIChcbiAgcGF0aCxcbiAgcGFyZW50LFxuICBzdHJpY3Rcbikge1xuICBpZiAoIXN0cmljdCkgeyBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpOyB9XG4gIGlmIChwYXRoWzBdID09PSAnLycpIHsgcmV0dXJuIHBhdGggfVxuICBpZiAocGFyZW50ID09IG51bGwpIHsgcmV0dXJuIHBhdGggfVxuICByZXR1cm4gY2xlYW5QYXRoKCgocGFyZW50LnBhdGgpICsgXCIvXCIgKyBwYXRoKSlcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaGVyIChcbiAgcm91dGVzLFxuICByb3V0ZXJcbikge1xuICB2YXIgcmVmID0gY3JlYXRlUm91dGVNYXAocm91dGVzKTtcbiAgdmFyIHBhdGhMaXN0ID0gcmVmLnBhdGhMaXN0O1xuICB2YXIgcGF0aE1hcCA9IHJlZi5wYXRoTWFwO1xuICB2YXIgbmFtZU1hcCA9IHJlZi5uYW1lTWFwO1xuXG4gIGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gICAgY3JlYXRlUm91dGVNYXAocm91dGVzLCBwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaCAoXG4gICAgcmF3LFxuICAgIGN1cnJlbnRSb3V0ZSxcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbihyYXcsIGN1cnJlbnRSb3V0ZSwgZmFsc2UsIHJvdXRlcik7XG4gICAgdmFyIG5hbWUgPSBsb2NhdGlvbi5uYW1lO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhciByZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihyZWNvcmQsIChcIlJvdXRlIHdpdGggbmFtZSAnXCIgKyBuYW1lICsgXCInIGRvZXMgbm90IGV4aXN0XCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVjb3JkKSB7IHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pIH1cbiAgICAgIHZhciBwYXJhbU5hbWVzID0gcmVjb3JkLnJlZ2V4LmtleXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAha2V5Lm9wdGlvbmFsOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleS5uYW1lOyB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbi5wYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudFJvdXRlICYmIHR5cGVvZiBjdXJyZW50Um91dGUucGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VycmVudFJvdXRlLnBhcmFtcykge1xuICAgICAgICAgIGlmICghKGtleSBpbiBsb2NhdGlvbi5wYXJhbXMpICYmIHBhcmFtTmFtZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uLnBhcmFtc1trZXldID0gY3VycmVudFJvdXRlLnBhcmFtc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsb2NhdGlvbi5wYXRoID0gZmlsbFBhcmFtcyhyZWNvcmQucGF0aCwgbG9jYXRpb24ucGFyYW1zLCAoXCJuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpKTtcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRoKSB7XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoTGlzdFtpXTtcbiAgICAgICAgdmFyIHJlY29yZCQxID0gcGF0aE1hcFtwYXRoXTtcbiAgICAgICAgaWYgKG1hdGNoUm91dGUocmVjb3JkJDEucmVnZXgsIGxvY2F0aW9uLnBhdGgsIGxvY2F0aW9uLnBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCQxLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm8gbWF0Y2hcbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkaXJlY3QgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvblxuICApIHtcbiAgICB2YXIgb3JpZ2luYWxSZWRpcmVjdCA9IHJlY29yZC5yZWRpcmVjdDtcbiAgICB2YXIgcmVkaXJlY3QgPSB0eXBlb2Ygb3JpZ2luYWxSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBvcmlnaW5hbFJlZGlyZWN0KGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIG51bGwsIHJvdXRlcikpXG4gICAgICA6IG9yaWdpbmFsUmVkaXJlY3Q7XG5cbiAgICBpZiAodHlwZW9mIHJlZGlyZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmVkaXJlY3QgPSB7IHBhdGg6IHJlZGlyZWN0IH07XG4gICAgfVxuXG4gICAgaWYgKCFyZWRpcmVjdCB8fCB0eXBlb2YgcmVkaXJlY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuXG4gICAgdmFyIHJlID0gcmVkaXJlY3Q7XG4gICAgdmFyIG5hbWUgPSByZS5uYW1lO1xuICAgIHZhciBwYXRoID0gcmUucGF0aDtcbiAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHBhcmFtcyA9IGxvY2F0aW9uLnBhcmFtcztcbiAgICBxdWVyeSA9IHJlLmhhc093blByb3BlcnR5KCdxdWVyeScpID8gcmUucXVlcnkgOiBxdWVyeTtcbiAgICBoYXNoID0gcmUuaGFzT3duUHJvcGVydHkoJ2hhc2gnKSA/IHJlLmhhc2ggOiBoYXNoO1xuICAgIHBhcmFtcyA9IHJlLmhhc093blByb3BlcnR5KCdwYXJhbXMnKSA/IHJlLnBhcmFtcyA6IHBhcmFtcztcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICAvLyByZXNvbHZlZCBuYW1lZCBkaXJlY3RcbiAgICAgIHZhciB0YXJnZXRSZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KHRhcmdldFJlY29yZCwgKFwicmVkaXJlY3QgZmFpbGVkOiBuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG5vdCBmb3VuZC5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIGlmIChwYXRoKSB7XG4gICAgICAvLyAxLiByZXNvbHZlIHJlbGF0aXZlIHJlZGlyZWN0XG4gICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHBhdGgsIHJlY29yZCk7XG4gICAgICAvLyAyLiByZXNvbHZlIHBhcmFtc1xuICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJyZWRpcmVjdCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgcmF3UGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBwYXRoOiByZXNvbHZlZFBhdGgsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaFxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWxpYXMgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICBtYXRjaEFzXG4gICkge1xuICAgIHZhciBhbGlhc2VkUGF0aCA9IGZpbGxQYXJhbXMobWF0Y2hBcywgbG9jYXRpb24ucGFyYW1zLCAoXCJhbGlhc2VkIHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyBtYXRjaEFzICsgXCJcXFwiXCIpKTtcbiAgICB2YXIgYWxpYXNlZE1hdGNoID0gbWF0Y2goe1xuICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICBwYXRoOiBhbGlhc2VkUGF0aFxuICAgIH0pO1xuICAgIGlmIChhbGlhc2VkTWF0Y2gpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gYWxpYXNlZE1hdGNoLm1hdGNoZWQ7XG4gICAgICB2YXIgYWxpYXNlZFJlY29yZCA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IGFsaWFzZWRNYXRjaC5wYXJhbXM7XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKGFsaWFzZWRSZWNvcmQsIGxvY2F0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVJvdXRlIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQucmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiByZWRpcmVjdChyZWNvcmQsIHJlZGlyZWN0ZWRGcm9tIHx8IGxvY2F0aW9uKVxuICAgIH1cbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5tYXRjaEFzKSB7XG4gICAgICByZXR1cm4gYWxpYXMocmVjb3JkLCBsb2NhdGlvbiwgcmVjb3JkLm1hdGNoQXMpXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSwgcm91dGVyKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgYWRkUm91dGVzOiBhZGRSb3V0ZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlIChcbiAgcmVnZXgsXG4gIHBhdGgsXG4gIHBhcmFtc1xuKSB7XG4gIHZhciBtID0gcGF0aC5tYXRjaChyZWdleCk7XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmb3IgKHZhciBpID0gMSwgbGVuID0gbS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBrZXkgPSByZWdleC5rZXlzW2kgLSAxXTtcbiAgICB2YXIgdmFsID0gdHlwZW9mIG1baV0gPT09ICdzdHJpbmcnID8gZGVjb2RlVVJJQ29tcG9uZW50KG1baV0pIDogbVtpXTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICAvLyBGaXggIzE5OTQ6IHVzaW5nICogd2l0aCBwcm9wczogdHJ1ZSBnZW5lcmF0ZXMgYSBwYXJhbSBuYW1lZCAwXG4gICAgICBwYXJhbXNba2V5Lm5hbWUgfHwgJ3BhdGhNYXRjaCddID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZWNvcmRQYXRoIChwYXRoLCByZWNvcmQpIHtcbiAgcmV0dXJuIHJlc29sdmVQYXRoKHBhdGgsIHJlY29yZC5wYXJlbnQgPyByZWNvcmQucGFyZW50LnBhdGggOiAnLycsIHRydWUpXG59XG5cbi8qICAqL1xuXG4vLyB1c2UgVXNlciBUaW1pbmcgYXBpIChpZiBwcmVzZW50KSBmb3IgbW9yZSBhY2N1cmF0ZSBrZXkgcHJlY2lzaW9uXG52YXIgVGltZSA9XG4gIGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vd1xuICAgID8gd2luZG93LnBlcmZvcm1hbmNlXG4gICAgOiBEYXRlO1xuXG5mdW5jdGlvbiBnZW5TdGF0ZUtleSAoKSB7XG4gIHJldHVybiBUaW1lLm5vdygpLnRvRml4ZWQoMylcbn1cblxudmFyIF9rZXkgPSBnZW5TdGF0ZUtleSgpO1xuXG5mdW5jdGlvbiBnZXRTdGF0ZUtleSAoKSB7XG4gIHJldHVybiBfa2V5XG59XG5cbmZ1bmN0aW9uIHNldFN0YXRlS2V5IChrZXkpIHtcbiAgcmV0dXJuIChfa2V5ID0ga2V5KVxufVxuXG4vKiAgKi9cblxudmFyIHBvc2l0aW9uU3RvcmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBzZXR1cFNjcm9sbCAoKSB7XG4gIC8vIEZpeCBmb3IgIzE1ODUgZm9yIEZpcmVmb3hcbiAgLy8gRml4IGZvciAjMjE5NSBBZGQgb3B0aW9uYWwgdGhpcmQgYXR0cmlidXRlIHRvIHdvcmthcm91bmQgYSBidWcgaW4gc2FmYXJpIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODI2NzhcbiAgLy8gRml4IGZvciAjMjc3NCBTdXBwb3J0IGZvciBhcHBzIGxvYWRlZCBmcm9tIFdpbmRvd3MgZmlsZSBzaGFyZXMgbm90IG1hcHBlZCB0byBuZXR3b3JrIGRyaXZlczogcmVwbGFjZWQgbG9jYXRpb24ub3JpZ2luIHdpdGhcbiAgLy8gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbmRvdy5sb2NhdGlvbi5ob3N0XG4gIC8vIGxvY2F0aW9uLmhvc3QgY29udGFpbnMgdGhlIHBvcnQgYW5kIGxvY2F0aW9uLmhvc3RuYW1lIGRvZXNuJ3RcbiAgdmFyIHByb3RvY29sQW5kUGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgdmFyIGFic29sdXRlUGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UocHJvdG9jb2xBbmRQYXRoLCAnJyk7XG4gIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleTogZ2V0U3RhdGVLZXkoKSB9LCAnJywgYWJzb2x1dGVQYXRoKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICBpZiAoZS5zdGF0ZSAmJiBlLnN0YXRlLmtleSkge1xuICAgICAgc2V0U3RhdGVLZXkoZS5zdGF0ZS5rZXkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNjcm9sbCAoXG4gIHJvdXRlcixcbiAgdG8sXG4gIGZyb20sXG4gIGlzUG9wXG4pIHtcbiAgaWYgKCFyb3V0ZXIuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmVoYXZpb3IgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcbiAgaWYgKCFiZWhhdmlvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJlaGF2aW9yID09PSAnZnVuY3Rpb24nLCBcInNjcm9sbEJlaGF2aW9yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIC8vIHdhaXQgdW50aWwgcmUtcmVuZGVyIGZpbmlzaGVzIGJlZm9yZSBzY3JvbGxpbmdcbiAgcm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgdmFyIHNob3VsZFNjcm9sbCA9IGJlaGF2aW9yLmNhbGwoXG4gICAgICByb3V0ZXIsXG4gICAgICB0byxcbiAgICAgIGZyb20sXG4gICAgICBpc1BvcCA/IHBvc2l0aW9uIDogbnVsbFxuICAgICk7XG5cbiAgICBpZiAoIXNob3VsZFNjcm9sbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzaG91bGRTY3JvbGwudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2hvdWxkU2Nyb2xsXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChzaG91bGRTY3JvbGwpIHtcbiAgICAgICAgICBzY3JvbGxUb1Bvc2l0aW9uKChzaG91bGRTY3JvbGwpLCBwb3NpdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcm9sbFRvUG9zaXRpb24oc2hvdWxkU2Nyb2xsLCBwb3NpdGlvbik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uICgpIHtcbiAgdmFyIGtleSA9IGdldFN0YXRlS2V5KCk7XG4gIGlmIChrZXkpIHtcbiAgICBwb3NpdGlvblN0b3JlW2tleV0gPSB7XG4gICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFBvc2l0aW9uICgpIHtcbiAgdmFyIGtleSA9IGdldFN0YXRlS2V5KCk7XG4gIGlmIChrZXkpIHtcbiAgICByZXR1cm4gcG9zaXRpb25TdG9yZVtrZXldXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFBvc2l0aW9uIChlbCwgb2Zmc2V0KSB7XG4gIHZhciBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGRvY1JlY3QgPSBkb2NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHg6IGVsUmVjdC5sZWZ0IC0gZG9jUmVjdC5sZWZ0IC0gb2Zmc2V0LngsXG4gICAgeTogZWxSZWN0LnRvcCAtIGRvY1JlY3QudG9wIC0gb2Zmc2V0LnlcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUG9zaXRpb24gKG9iaikge1xuICByZXR1cm4gaXNOdW1iZXIob2JqLngpIHx8IGlzTnVtYmVyKG9iai55KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgeDogaXNOdW1iZXIob2JqLngpID8gb2JqLnggOiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgeTogaXNOdW1iZXIob2JqLnkpID8gb2JqLnkgOiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPZmZzZXQgKG9iaikge1xuICByZXR1cm4ge1xuICAgIHg6IGlzTnVtYmVyKG9iai54KSA/IG9iai54IDogMCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IDBcbiAgfVxufVxuXG5mdW5jdGlvbiBpc051bWJlciAodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdudW1iZXInXG59XG5cbnZhciBoYXNoU3RhcnRzV2l0aE51bWJlclJFID0gL14jXFxkLztcblxuZnVuY3Rpb24gc2Nyb2xsVG9Qb3NpdGlvbiAoc2hvdWxkU2Nyb2xsLCBwb3NpdGlvbikge1xuICB2YXIgaXNPYmplY3QgPSB0eXBlb2Ygc2hvdWxkU2Nyb2xsID09PSAnb2JqZWN0JztcbiAgaWYgKGlzT2JqZWN0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZ2V0RWxlbWVudEJ5SWQgd291bGQgc3RpbGwgZmFpbCBpZiB0aGUgc2VsZWN0b3IgY29udGFpbnMgYSBtb3JlIGNvbXBsaWNhdGVkIHF1ZXJ5IGxpa2UgI21haW5bZGF0YS1hdHRyXVxuICAgIC8vIGJ1dCBhdCB0aGUgc2FtZSB0aW1lLCBpdCBkb2Vzbid0IG1ha2UgbXVjaCBzZW5zZSB0byBzZWxlY3QgYW4gZWxlbWVudCB3aXRoIGFuIGlkIGFuZCBhbiBleHRyYSBzZWxlY3RvclxuICAgIHZhciBlbCA9IGhhc2hTdGFydHNXaXRoTnVtYmVyUkUudGVzdChzaG91bGRTY3JvbGwuc2VsZWN0b3IpIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzaG91bGRTY3JvbGwuc2VsZWN0b3Iuc2xpY2UoMSkpIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNob3VsZFNjcm9sbC5zZWxlY3Rvcik7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIHZhciBvZmZzZXQgPVxuICAgICAgICBzaG91bGRTY3JvbGwub2Zmc2V0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwub2Zmc2V0ID09PSAnb2JqZWN0J1xuICAgICAgICAgID8gc2hvdWxkU2Nyb2xsLm9mZnNldFxuICAgICAgICAgIDoge307XG4gICAgICBvZmZzZXQgPSBub3JtYWxpemVPZmZzZXQob2Zmc2V0KTtcbiAgICAgIHBvc2l0aW9uID0gZ2V0RWxlbWVudFBvc2l0aW9uKGVsLCBvZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QgJiYgaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gIH1cblxuICBpZiAocG9zaXRpb24pIHtcbiAgICB3aW5kb3cuc2Nyb2xsVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9XG4gIGluQnJvd3NlciAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gICAgaWYgKFxuICAgICAgKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmXG4gICAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG4gICAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcbiAgICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTFcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeVxuICB9KSgpO1xuXG5mdW5jdGlvbiBwdXNoU3RhdGUgKHVybCwgcmVwbGFjZSkge1xuICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgLy8gdHJ5Li4uY2F0Y2ggdGhlIHB1c2hTdGF0ZSBjYWxsIHRvIGdldCBhcm91bmQgU2FmYXJpXG4gIC8vIERPTSBFeGNlcHRpb24gMTggd2hlcmUgaXQgbGltaXRzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHNcbiAgdmFyIGhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IGdldFN0YXRlS2V5KCkgfSwgJycsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBzZXRTdGF0ZUtleShnZW5TdGF0ZUtleSgpKSB9LCAnJywgdXJsKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB3aW5kb3cubG9jYXRpb25bcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdhc3NpZ24nXSh1cmwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAodXJsKSB7XG4gIHB1c2hTdGF0ZSh1cmwsIHRydWUpO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcnVuUXVldWUgKHF1ZXVlLCBmbiwgY2IpIHtcbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gcXVldWUubGVuZ3RoKSB7XG4gICAgICBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocXVldWVbaW5kZXhdKSB7XG4gICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGVwKDApO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyAobWF0Y2hlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgdmFyIGhhc0FzeW5jID0gZmFsc2U7XG4gICAgdmFyIHBlbmRpbmcgPSAwO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG5cbiAgICBmbGF0TWFwQ29tcG9uZW50cyhtYXRjaGVkLCBmdW5jdGlvbiAoZGVmLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgICAvLyBpZiBpdCdzIGEgZnVuY3Rpb24gYW5kIGRvZXNuJ3QgaGF2ZSBjaWQgYXR0YWNoZWQsXG4gICAgICAvLyBhc3N1bWUgaXQncyBhbiBhc3luYyBjb21wb25lbnQgcmVzb2x2ZSBmdW5jdGlvbi5cbiAgICAgIC8vIHdlIGFyZSBub3QgdXNpbmcgVnVlJ3MgZGVmYXVsdCBhc3luYyByZXNvbHZpbmcgbWVjaGFuaXNtIGJlY2F1c2VcbiAgICAgIC8vIHdlIHdhbnQgdG8gaGFsdCB0aGUgbmF2aWdhdGlvbiB1bnRpbCB0aGUgaW5jb21pbmcgY29tcG9uZW50IGhhcyBiZWVuXG4gICAgICAvLyByZXNvbHZlZC5cbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGRlZi5jaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoYXNBc3luYyA9IHRydWU7XG4gICAgICAgIHBlbmRpbmcrKztcblxuICAgICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlc29sdmVkRGVmKSB7XG4gICAgICAgICAgaWYgKGlzRVNNb2R1bGUocmVzb2x2ZWREZWYpKSB7XG4gICAgICAgICAgICByZXNvbHZlZERlZiA9IHJlc29sdmVkRGVmLmRlZmF1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNhdmUgcmVzb2x2ZWQgb24gYXN5bmMgZmFjdG9yeSBpbiBjYXNlIGl0J3MgdXNlZCBlbHNld2hlcmVcbiAgICAgICAgICBkZWYucmVzb2x2ZWQgPSB0eXBlb2YgcmVzb2x2ZWREZWYgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcmVzb2x2ZWREZWZcbiAgICAgICAgICAgIDogX1Z1ZS5leHRlbmQocmVzb2x2ZWREZWYpO1xuICAgICAgICAgIG1hdGNoLmNvbXBvbmVudHNba2V5XSA9IHJlc29sdmVkRGVmO1xuICAgICAgICAgIHBlbmRpbmctLTtcbiAgICAgICAgICBpZiAocGVuZGluZyA8PSAwKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgdmFyIG1zZyA9IFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50IFwiICsga2V5ICsgXCI6IFwiICsgcmVhc29uO1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgbXNnKTtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IGlzRXJyb3IocmVhc29uKVxuICAgICAgICAgICAgICA/IHJlYXNvblxuICAgICAgICAgICAgICA6IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IGRlZihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBuZXcgc3ludGF4IGluIFZ1ZSAyLjNcbiAgICAgICAgICAgIHZhciBjb21wID0gcmVzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGlmIChjb21wICYmIHR5cGVvZiBjb21wLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY29tcC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWhhc0FzeW5jKSB7IG5leHQoKTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXRNYXBDb21wb25lbnRzIChcbiAgbWF0Y2hlZCxcbiAgZm5cbikge1xuICByZXR1cm4gZmxhdHRlbihtYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihcbiAgICAgIG0uY29tcG9uZW50c1trZXldLFxuICAgICAgbS5pbnN0YW5jZXNba2V5XSxcbiAgICAgIG0sIGtleVxuICAgICk7IH0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuIChhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycilcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbmZ1bmN0aW9uIGlzRVNNb2R1bGUgKG9iaikge1xuICByZXR1cm4gb2JqLl9fZXNNb2R1bGUgfHwgKGhhc1N5bWJvbCAmJiBvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG59XG5cbi8vIGluIFdlYnBhY2sgMiwgcmVxdWlyZS5lbnN1cmUgbm93IGFsc28gcmV0dXJucyBhIFByb21pc2Vcbi8vIHNvIHRoZSByZXNvbHZlL3JlamVjdCBmdW5jdGlvbnMgbWF5IGdldCBjYWxsZWQgYW4gZXh0cmEgdGltZVxuLy8gaWYgdGhlIHVzZXIgdXNlcyBhbiBhcnJvdyBmdW5jdGlvbiBzaG9ydGhhbmQgdGhhdCBoYXBwZW5zIHRvXG4vLyByZXR1cm4gdGhhdCBQcm9taXNlLlxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIGlmIChjYWxsZWQpIHsgcmV0dXJuIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICB9XG59XG5cbnZhciBOYXZpZ2F0aW9uRHVwbGljYXRlZCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEVycm9yKSB7XG4gIGZ1bmN0aW9uIE5hdmlnYXRpb25EdXBsaWNhdGVkIChub3JtYWxpemVkTG9jYXRpb24pIHtcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuX25hbWUgPSAnTmF2aWdhdGlvbkR1cGxpY2F0ZWQnO1xuICAgIC8vIHBhc3NpbmcgdGhlIG1lc3NhZ2UgdG8gc3VwZXIoKSBkb2Vzbid0IHNlZW0gdG8gd29yayBpbiB0aGUgdHJhbnNwaWxlZCB2ZXJzaW9uXG4gICAgdGhpcy5tZXNzYWdlID0gXCJOYXZpZ2F0aW5nIHRvIGN1cnJlbnQgbG9jYXRpb24gKFxcXCJcIiArIChub3JtYWxpemVkTG9jYXRpb24uZnVsbFBhdGgpICsgXCJcXFwiKSBpcyBub3QgYWxsb3dlZFwiO1xuICAgIC8vIGFkZCBhIHN0YWNrIHByb3BlcnR5IHNvIHNlcnZpY2VzIGxpa2UgU2VudHJ5IGNhbiBjb3JyZWN0bHkgZGlzcGxheSBpdFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhY2snLCB7XG4gICAgICB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2ssXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIHdlIGNvdWxkIGFsc28gaGF2ZSB1c2VkXG4gICAgLy8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3RvcilcbiAgICAvLyBidXQgaXQgb25seSBleGlzdHMgb24gbm9kZSBhbmQgY2hyb21lXG4gIH1cblxuICBpZiAoIEVycm9yICkgTmF2aWdhdGlvbkR1cGxpY2F0ZWQuX19wcm90b19fID0gRXJyb3I7XG4gIE5hdmlnYXRpb25EdXBsaWNhdGVkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVycm9yICYmIEVycm9yLnByb3RvdHlwZSApO1xuICBOYXZpZ2F0aW9uRHVwbGljYXRlZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOYXZpZ2F0aW9uRHVwbGljYXRlZDtcblxuICByZXR1cm4gTmF2aWdhdGlvbkR1cGxpY2F0ZWQ7XG59KEVycm9yKSk7XG5cbi8vIHN1cHBvcnQgSUU5XG5OYXZpZ2F0aW9uRHVwbGljYXRlZC5fbmFtZSA9ICdOYXZpZ2F0aW9uRHVwbGljYXRlZCc7XG5cbi8qICAqL1xuXG52YXIgSGlzdG9yeSA9IGZ1bmN0aW9uIEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgdGhpcy5iYXNlID0gbm9ybWFsaXplQmFzZShiYXNlKTtcbiAgLy8gc3RhcnQgd2l0aCBhIHJvdXRlIG9iamVjdCB0aGF0IHN0YW5kcyBmb3IgXCJub3doZXJlXCJcbiAgdGhpcy5jdXJyZW50ID0gU1RBUlQ7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7XG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgdGhpcy5yZWFkeUNicyA9IFtdO1xuICB0aGlzLnJlYWR5RXJyb3JDYnMgPSBbXTtcbiAgdGhpcy5lcnJvckNicyA9IFtdO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuIChjYikge1xuICB0aGlzLmNiID0gY2I7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeSAoY2IsIGVycm9yQ2IpIHtcbiAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICBjYigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVhZHlDYnMucHVzaChjYik7XG4gICAgaWYgKGVycm9yQ2IpIHtcbiAgICAgIHRoaXMucmVhZHlFcnJvckNicy5wdXNoKGVycm9yQ2IpO1xuICAgIH1cbiAgfVxufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5lcnJvckNicy5wdXNoKGVycm9yQ2IpO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvIChcbiAgbG9jYXRpb24sXG4gIG9uQ29tcGxldGUsXG4gIG9uQWJvcnRcbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciByb3V0ZSA9IHRoaXMucm91dGVyLm1hdGNoKGxvY2F0aW9uLCB0aGlzLmN1cnJlbnQpO1xuICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKFxuICAgIHJvdXRlLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgICAgdGhpcyQxLmVuc3VyZVVSTCgpO1xuXG4gICAgICAvLyBmaXJlIHJlYWR5IGNicyBvbmNlXG4gICAgICBpZiAoIXRoaXMkMS5yZWFkeSkge1xuICAgICAgICB0aGlzJDEucmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzJDEucmVhZHlDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICBjYihyb3V0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKG9uQWJvcnQpIHtcbiAgICAgICAgb25BYm9ydChlcnIpO1xuICAgICAgfVxuICAgICAgaWYgKGVyciAmJiAhdGhpcyQxLnJlYWR5KSB7XG4gICAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMkMS5yZWFkeUVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICApO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUsIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKGVycikge1xuICAgIC8vIGFmdGVyIG1lcmdpbmcgaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1yb3V0ZXIvcHVsbC8yNzcxIHdlXG4gICAgLy8gV2hlbiB0aGUgdXNlciBuYXZpZ2F0ZXMgdGhyb3VnaCBoaXN0b3J5IHRocm91Z2ggYmFjay9mb3J3YXJkIGJ1dHRvbnNcbiAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byB0aHJvdyB0aGUgZXJyb3IuIFdlIG9ubHkgdGhyb3cgaXQgaWYgZGlyZWN0bHkgY2FsbGluZ1xuICAgIC8vIHB1c2gvcmVwbGFjZS4gVGhhdCdzIHdoeSBpdCdzIG5vdCBpbmNsdWRlZCBpbiBpc0Vycm9yXG4gICAgaWYgKCFpc0V4dGVuZGVkRXJyb3IoTmF2aWdhdGlvbkR1cGxpY2F0ZWQsIGVycikgJiYgaXNFcnJvcihlcnIpKSB7XG4gICAgICBpZiAodGhpcyQxLmVycm9yQ2JzLmxlbmd0aCkge1xuICAgICAgICB0aGlzJDEuZXJyb3JDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oZmFsc2UsICd1bmNhdWdodCBlcnJvciBkdXJpbmcgcm91dGUgbmF2aWdhdGlvbjonKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbkFib3J0ICYmIG9uQWJvcnQoZXJyKTtcbiAgfTtcbiAgaWYgKFxuICAgIGlzU2FtZVJvdXRlKHJvdXRlLCBjdXJyZW50KSAmJlxuICAgIC8vIGluIHRoZSBjYXNlIHRoZSByb3V0ZSBtYXAgaGFzIGJlZW4gZHluYW1pY2FsbHkgYXBwZW5kZWQgdG9cbiAgICByb3V0ZS5tYXRjaGVkLmxlbmd0aCA9PT0gY3VycmVudC5tYXRjaGVkLmxlbmd0aFxuICApIHtcbiAgICB0aGlzLmVuc3VyZVVSTCgpO1xuICAgIHJldHVybiBhYm9ydChuZXcgTmF2aWdhdGlvbkR1cGxpY2F0ZWQocm91dGUpKVxuICB9XG5cbiAgdmFyIHJlZiA9IHJlc29sdmVRdWV1ZShcbiAgICB0aGlzLmN1cnJlbnQubWF0Y2hlZCxcbiAgICByb3V0ZS5tYXRjaGVkXG4gICk7XG4gICAgdmFyIHVwZGF0ZWQgPSByZWYudXBkYXRlZDtcbiAgICB2YXIgZGVhY3RpdmF0ZWQgPSByZWYuZGVhY3RpdmF0ZWQ7XG4gICAgdmFyIGFjdGl2YXRlZCA9IHJlZi5hY3RpdmF0ZWQ7XG5cbiAgdmFyIHF1ZXVlID0gW10uY29uY2F0KFxuICAgIC8vIGluLWNvbXBvbmVudCBsZWF2ZSBndWFyZHNcbiAgICBleHRyYWN0TGVhdmVHdWFyZHMoZGVhY3RpdmF0ZWQpLFxuICAgIC8vIGdsb2JhbCBiZWZvcmUgaG9va3NcbiAgICB0aGlzLnJvdXRlci5iZWZvcmVIb29rcyxcbiAgICAvLyBpbi1jb21wb25lbnQgdXBkYXRlIGhvb2tzXG4gICAgZXh0cmFjdFVwZGF0ZUhvb2tzKHVwZGF0ZWQpLFxuICAgIC8vIGluLWNvbmZpZyBlbnRlciBndWFyZHNcbiAgICBhY3RpdmF0ZWQubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmJlZm9yZUVudGVyOyB9KSxcbiAgICAvLyBhc3luYyBjb21wb25lbnRzXG4gICAgcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyhhY3RpdmF0ZWQpXG4gICk7XG5cbiAgdGhpcy5wZW5kaW5nID0gcm91dGU7XG4gIHZhciBpdGVyYXRvciA9IGZ1bmN0aW9uIChob29rLCBuZXh0KSB7XG4gICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgcmV0dXJuIGFib3J0KClcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGhvb2socm91dGUsIGN1cnJlbnQsIGZ1bmN0aW9uICh0bykge1xuICAgICAgICBpZiAodG8gPT09IGZhbHNlIHx8IGlzRXJyb3IodG8pKSB7XG4gICAgICAgICAgLy8gbmV4dChmYWxzZSkgLT4gYWJvcnQgbmF2aWdhdGlvbiwgZW5zdXJlIGN1cnJlbnQgVVJMXG4gICAgICAgICAgdGhpcyQxLmVuc3VyZVVSTCh0cnVlKTtcbiAgICAgICAgICBhYm9ydCh0byk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgdHlwZW9mIHRvID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICh0eXBlb2YgdG8gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAodHlwZW9mIHRvLnBhdGggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0by5uYW1lID09PSAnc3RyaW5nJykpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5leHQoJy8nKSBvciBuZXh0KHsgcGF0aDogJy8nIH0pIC0+IHJlZGlyZWN0XG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiB0by5yZXBsYWNlKSB7XG4gICAgICAgICAgICB0aGlzJDEucmVwbGFjZSh0byk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMkMS5wdXNoKHRvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uZmlybSB0cmFuc2l0aW9uIGFuZCBwYXNzIG9uIHRoZSB2YWx1ZVxuICAgICAgICAgIG5leHQodG8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydChlKTtcbiAgICB9XG4gIH07XG5cbiAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc3RFbnRlckNicyA9IFtdO1xuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmN1cnJlbnQgPT09IHJvdXRlOyB9O1xuICAgIC8vIHdhaXQgdW50aWwgYXN5bmMgY29tcG9uZW50cyBhcmUgcmVzb2x2ZWQgYmVmb3JlXG4gICAgLy8gZXh0cmFjdGluZyBpbi1jb21wb25lbnQgZW50ZXIgZ3VhcmRzXG4gICAgdmFyIGVudGVyR3VhcmRzID0gZXh0cmFjdEVudGVyR3VhcmRzKGFjdGl2YXRlZCwgcG9zdEVudGVyQ2JzLCBpc1ZhbGlkKTtcbiAgICB2YXIgcXVldWUgPSBlbnRlckd1YXJkcy5jb25jYXQodGhpcyQxLnJvdXRlci5yZXNvbHZlSG9va3MpO1xuICAgIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gYWJvcnQoKVxuICAgICAgfVxuICAgICAgdGhpcyQxLnBlbmRpbmcgPSBudWxsO1xuICAgICAgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgICBpZiAodGhpcyQxLnJvdXRlci5hcHApIHtcbiAgICAgICAgdGhpcyQxLnJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwb3N0RW50ZXJDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnVwZGF0ZVJvdXRlID0gZnVuY3Rpb24gdXBkYXRlUm91dGUgKHJvdXRlKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50O1xuICB0aGlzLmN1cnJlbnQgPSByb3V0ZTtcbiAgdGhpcy5jYiAmJiB0aGlzLmNiKHJvdXRlKTtcbiAgdGhpcy5yb3V0ZXIuYWZ0ZXJIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9vayAmJiBob29rKHJvdXRlLCBwcmV2KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVCYXNlIChiYXNlKSB7XG4gIGlmICghYmFzZSkge1xuICAgIGlmIChpbkJyb3dzZXIpIHtcbiAgICAgIC8vIHJlc3BlY3QgPGJhc2U+IHRhZ1xuICAgICAgdmFyIGJhc2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICAgIGJhc2UgPSAoYmFzZUVsICYmIGJhc2VFbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgfHwgJy8nO1xuICAgICAgLy8gc3RyaXAgZnVsbCBVUkwgb3JpZ2luXG4gICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcL1teXFwvXSsvLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnLyc7XG4gICAgfVxuICB9XG4gIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIHRoZSBzdGFydGluZyBzbGFzaFxuICBpZiAoYmFzZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGJhc2UgPSAnLycgKyBiYXNlO1xuICB9XG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICByZXR1cm4gYmFzZS5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWV1ZSAoXG4gIGN1cnJlbnQsXG4gIG5leHRcbikge1xuICB2YXIgaTtcbiAgdmFyIG1heCA9IE1hdGgubWF4KGN1cnJlbnQubGVuZ3RoLCBuZXh0Lmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGlmIChjdXJyZW50W2ldICE9PSBuZXh0W2ldKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZWQ6IG5leHQuc2xpY2UoMCwgaSksXG4gICAgYWN0aXZhdGVkOiBuZXh0LnNsaWNlKGkpLFxuICAgIGRlYWN0aXZhdGVkOiBjdXJyZW50LnNsaWNlKGkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkcyAoXG4gIHJlY29yZHMsXG4gIG5hbWUsXG4gIGJpbmQsXG4gIHJldmVyc2Vcbikge1xuICB2YXIgZ3VhcmRzID0gZmxhdE1hcENvbXBvbmVudHMocmVjb3JkcywgZnVuY3Rpb24gKGRlZiwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpIHtcbiAgICB2YXIgZ3VhcmQgPSBleHRyYWN0R3VhcmQoZGVmLCBuYW1lKTtcbiAgICBpZiAoZ3VhcmQpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGd1YXJkKVxuICAgICAgICA/IGd1YXJkLm1hcChmdW5jdGlvbiAoZ3VhcmQpIHsgcmV0dXJuIGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KTsgfSlcbiAgICAgICAgOiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSlcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmxhdHRlbihyZXZlcnNlID8gZ3VhcmRzLnJldmVyc2UoKSA6IGd1YXJkcylcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkIChcbiAgZGVmLFxuICBrZXlcbikge1xuICBpZiAodHlwZW9mIGRlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGV4dGVuZCBub3cgc28gdGhhdCBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkLlxuICAgIGRlZiA9IF9WdWUuZXh0ZW5kKGRlZik7XG4gIH1cbiAgcmV0dXJuIGRlZi5vcHRpb25zW2tleV1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdExlYXZlR3VhcmRzIChkZWFjdGl2YXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhkZWFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlTGVhdmUnLCBiaW5kR3VhcmQsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RVcGRhdGVIb29rcyAodXBkYXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyh1cGRhdGVkLCAnYmVmb3JlUm91dGVVcGRhdGUnLCBiaW5kR3VhcmQpXG59XG5cbmZ1bmN0aW9uIGJpbmRHdWFyZCAoZ3VhcmQsIGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZFJvdXRlR3VhcmQgKCkge1xuICAgICAgcmV0dXJuIGd1YXJkLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFbnRlckd1YXJkcyAoXG4gIGFjdGl2YXRlZCxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoXG4gICAgYWN0aXZhdGVkLFxuICAgICdiZWZvcmVSb3V0ZUVudGVyJyxcbiAgICBmdW5jdGlvbiAoZ3VhcmQsIF8sIG1hdGNoLCBrZXkpIHtcbiAgICAgIHJldHVybiBiaW5kRW50ZXJHdWFyZChndWFyZCwgbWF0Y2gsIGtleSwgY2JzLCBpc1ZhbGlkKVxuICAgIH1cbiAgKVxufVxuXG5mdW5jdGlvbiBiaW5kRW50ZXJHdWFyZCAoXG4gIGd1YXJkLFxuICBtYXRjaCxcbiAga2V5LFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZnVuY3Rpb24gcm91dGVFbnRlckd1YXJkICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHJldHVybiBndWFyZCh0bywgZnJvbSwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNicy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAjNzUwXG4gICAgICAgICAgLy8gaWYgYSByb3V0ZXItdmlldyBpcyB3cmFwcGVkIHdpdGggYW4gb3V0LWluIHRyYW5zaXRpb24sXG4gICAgICAgICAgLy8gdGhlIGluc3RhbmNlIG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgYXQgdGhpcyB0aW1lLlxuICAgICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0byBwb2xsIGZvciByZWdpc3RyYXRpb24gdW50aWwgY3VycmVudCByb3V0ZVxuICAgICAgICAgIC8vIGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgICAgICBwb2xsKGNiLCBtYXRjaC5pbnN0YW5jZXMsIGtleSwgaXNWYWxpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbmV4dChjYik7XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2xsIChcbiAgY2IsIC8vIHNvbWVob3cgZmxvdyBjYW5ub3QgaW5mZXIgdGhpcyBpcyBhIGZ1bmN0aW9uXG4gIGluc3RhbmNlcyxcbiAga2V5LFxuICBpc1ZhbGlkXG4pIHtcbiAgaWYgKFxuICAgIGluc3RhbmNlc1trZXldICYmXG4gICAgIWluc3RhbmNlc1trZXldLl9pc0JlaW5nRGVzdHJveWVkIC8vIGRvIG5vdCByZXVzZSBiZWluZyBkZXN0cm95ZWQgaW5zdGFuY2VcbiAgKSB7XG4gICAgY2IoaW5zdGFuY2VzW2tleV0pO1xuICB9IGVsc2UgaWYgKGlzVmFsaWQoKSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcG9sbChjYiwgaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgIH0sIDE2KTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIEhUTUw1SGlzdG9yeSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEhpc3RvcnkpIHtcbiAgZnVuY3Rpb24gSFRNTDVIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIEhpc3RvcnkuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuXG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICAgIHZhciBzdXBwb3J0c1Njcm9sbCA9IHN1cHBvcnRzUHVzaFN0YXRlICYmIGV4cGVjdFNjcm9sbDtcblxuICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xuICAgICAgc2V0dXBTY3JvbGwoKTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdExvY2F0aW9uID0gZ2V0TG9jYXRpb24odGhpcy5iYXNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzJDEuY3VycmVudDtcblxuICAgICAgLy8gQXZvaWRpbmcgZmlyc3QgYHBvcHN0YXRlYCBldmVudCBkaXNwYXRjaGVkIGluIHNvbWUgYnJvd3NlcnMgYnV0IGZpcnN0XG4gICAgICAvLyBoaXN0b3J5IHJvdXRlIG5vdCB1cGRhdGVkIHNpbmNlIGFzeW5jIGd1YXJkIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbih0aGlzJDEuYmFzZSk7XG4gICAgICBpZiAodGhpcyQxLmN1cnJlbnQgPT09IFNUQVJUICYmIGxvY2F0aW9uID09PSBpbml0TG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAoc3VwcG9ydHNTY3JvbGwpIHtcbiAgICAgICAgICBoYW5kbGVTY3JvbGwocm91dGVyLCByb3V0ZSwgY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5ICkgSFRNTDVIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3Rvcnk7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5ICYmIEhpc3RvcnkucHJvdG90eXBlICk7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MNUhpc3Rvcnk7XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZVN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIGlmIChnZXRMb2NhdGlvbih0aGlzLmJhc2UpICE9PSB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gY2xlYW5QYXRoKHRoaXMuYmFzZSArIHRoaXMuY3VycmVudC5mdWxsUGF0aCk7XG4gICAgICBwdXNoID8gcHVzaFN0YXRlKGN1cnJlbnQpIDogcmVwbGFjZVN0YXRlKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldExvY2F0aW9uKHRoaXMuYmFzZSlcbiAgfTtcblxuICByZXR1cm4gSFRNTDVIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGdldExvY2F0aW9uIChiYXNlKSB7XG4gIHZhciBwYXRoID0gZGVjb2RlVVJJKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gIGlmIChiYXNlICYmIHBhdGguaW5kZXhPZihiYXNlKSA9PT0gMCkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaFxufVxuXG4vKiAgKi9cblxudmFyIEhhc2hIaXN0b3J5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSGlzdG9yeSkge1xuICBmdW5jdGlvbiBIYXNoSGlzdG9yeSAocm91dGVyLCBiYXNlLCBmYWxsYmFjaykge1xuICAgIEhpc3RvcnkuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIC8vIGNoZWNrIGhpc3RvcnkgZmFsbGJhY2sgZGVlcGxpbmtpbmdcbiAgICBpZiAoZmFsbGJhY2sgJiYgY2hlY2tGYWxsYmFjayh0aGlzLmJhc2UpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZW5zdXJlU2xhc2goKTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSApIEhhc2hIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3Rvcnk7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkgJiYgSGlzdG9yeS5wcm90b3R5cGUgKTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGFzaEhpc3Rvcnk7XG5cbiAgLy8gdGhpcyBpcyBkZWxheWVkIHVudGlsIHRoZSBhcHAgbW91bnRzXG4gIC8vIHRvIGF2b2lkIHRoZSBoYXNoY2hhbmdlIGxpc3RlbmVyIGJlaW5nIGZpcmVkIHRvbyBlYXJseVxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuc2V0dXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXR1cExpc3RlbmVycyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICAgIHZhciBzdXBwb3J0c1Njcm9sbCA9IHN1cHBvcnRzUHVzaFN0YXRlICYmIGV4cGVjdFNjcm9sbDtcblxuICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xuICAgICAgc2V0dXBTY3JvbGwoKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIHN1cHBvcnRzUHVzaFN0YXRlID8gJ3BvcHN0YXRlJyA6ICdoYXNoY2hhbmdlJyxcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzJDEuY3VycmVudDtcbiAgICAgICAgaWYgKCFlbnN1cmVTbGFzaCgpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcyQxLnRyYW5zaXRpb25UbyhnZXRIYXNoKCksIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xuICAgICAgICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBjdXJyZW50LCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdXBwb3J0c1B1c2hTdGF0ZSkge1xuICAgICAgICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8oXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBwdXNoSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgICB9LFxuICAgICAgb25BYm9ydFxuICAgICk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgICAgfSxcbiAgICAgIG9uQWJvcnRcbiAgICApO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoO1xuICAgIGlmIChnZXRIYXNoKCkgIT09IGN1cnJlbnQpIHtcbiAgICAgIHB1c2ggPyBwdXNoSGFzaChjdXJyZW50KSA6IHJlcGxhY2VIYXNoKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SGFzaCgpXG4gIH07XG5cbiAgcmV0dXJuIEhhc2hIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGNoZWNrRmFsbGJhY2sgKGJhc2UpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oYmFzZSk7XG4gIGlmICghL15cXC8jLy50ZXN0KGxvY2F0aW9uKSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGNsZWFuUGF0aChiYXNlICsgJy8jJyArIGxvY2F0aW9uKSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVTbGFzaCAoKSB7XG4gIHZhciBwYXRoID0gZ2V0SGFzaCgpO1xuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmVwbGFjZUhhc2goJy8nICsgcGF0aCk7XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZXRIYXNoICgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgLy8gZW1wdHkgcGF0aFxuICBpZiAoaW5kZXggPCAwKSB7IHJldHVybiAnJyB9XG5cbiAgaHJlZiA9IGhyZWYuc2xpY2UoaW5kZXggKyAxKTtcbiAgLy8gZGVjb2RlIHRoZSBoYXNoIGJ1dCBub3QgdGhlIHNlYXJjaCBvciBoYXNoXG4gIC8vIGFzIHNlYXJjaChxdWVyeSkgaXMgYWxyZWFkeSBkZWNvZGVkXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtcm91dGVyL2lzc3Vlcy8yNzA4XG4gIHZhciBzZWFyY2hJbmRleCA9IGhyZWYuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggPCAwKSB7XG4gICAgdmFyIGhhc2hJbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNoSW5kZXggPiAtMSkge1xuICAgICAgaHJlZiA9IGRlY29kZVVSSShocmVmLnNsaWNlKDAsIGhhc2hJbmRleCkpICsgaHJlZi5zbGljZShoYXNoSW5kZXgpO1xuICAgIH0gZWxzZSB7IGhyZWYgPSBkZWNvZGVVUkkoaHJlZik7IH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2VhcmNoSW5kZXggPiAtMSkge1xuICAgICAgaHJlZiA9IGRlY29kZVVSSShocmVmLnNsaWNlKDAsIHNlYXJjaEluZGV4KSkgKyBocmVmLnNsaWNlKHNlYXJjaEluZGV4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaHJlZlxufVxuXG5mdW5jdGlvbiBnZXRVcmwgKHBhdGgpIHtcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGkgPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgdmFyIGJhc2UgPSBpID49IDAgPyBocmVmLnNsaWNlKDAsIGkpIDogaHJlZjtcbiAgcmV0dXJuIChiYXNlICsgXCIjXCIgKyBwYXRoKVxufVxuXG5mdW5jdGlvbiBwdXNoSGFzaCAocGF0aCkge1xuICBpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcbiAgICBwdXNoU3RhdGUoZ2V0VXJsKHBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhhc2ggKHBhdGgpIHtcbiAgaWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XG4gICAgcmVwbGFjZVN0YXRlKGdldFVybChwYXRoKSk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoZ2V0VXJsKHBhdGgpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIEFic3RyYWN0SGlzdG9yeSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEhpc3RvcnkpIHtcbiAgZnVuY3Rpb24gQWJzdHJhY3RIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICBIaXN0b3J5LmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy5pbmRleCA9IC0xO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5ICkgQWJzdHJhY3RIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3Rvcnk7XG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5ICYmIEhpc3RvcnkucHJvdG90eXBlICk7XG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBYnN0cmFjdEhpc3Rvcnk7XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCArIDEpLmNvbmNhdChyb3V0ZSk7XG4gICAgICAgIHRoaXMkMS5pbmRleCsrO1xuICAgICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgICAgfSxcbiAgICAgIG9uQWJvcnRcbiAgICApO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25UbyhcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXgpLmNvbmNhdChyb3V0ZSk7XG4gICAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgICB9LFxuICAgICAgb25BYm9ydFxuICAgICk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0SW5kZXggPSB0aGlzLmluZGV4ICsgbjtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHJvdXRlID0gdGhpcy5zdGFja1t0YXJnZXRJbmRleF07XG4gICAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihcbiAgICAgIHJvdXRlLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzJDEuaW5kZXggPSB0YXJnZXRJbmRleDtcbiAgICAgICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChpc0V4dGVuZGVkRXJyb3IoTmF2aWdhdGlvbkR1cGxpY2F0ZWQsIGVycikpIHtcbiAgICAgICAgICB0aGlzJDEuaW5kZXggPSB0YXJnZXRJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBjdXJyZW50ID8gY3VycmVudC5mdWxsUGF0aCA6ICcvJ1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMICgpIHtcbiAgICAvLyBub29wXG4gIH07XG5cbiAgcmV0dXJuIEFic3RyYWN0SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG4vKiAgKi9cblxuXG5cbnZhciBWdWVSb3V0ZXIgPSBmdW5jdGlvbiBWdWVSb3V0ZXIgKG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdGhpcy5hcHAgPSBudWxsO1xuICB0aGlzLmFwcHMgPSBbXTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5iZWZvcmVIb29rcyA9IFtdO1xuICB0aGlzLnJlc29sdmVIb29rcyA9IFtdO1xuICB0aGlzLmFmdGVySG9va3MgPSBbXTtcbiAgdGhpcy5tYXRjaGVyID0gY3JlYXRlTWF0Y2hlcihvcHRpb25zLnJvdXRlcyB8fCBbXSwgdGhpcyk7XG5cbiAgdmFyIG1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJ2hhc2gnO1xuICB0aGlzLmZhbGxiYWNrID0gbW9kZSA9PT0gJ2hpc3RvcnknICYmICFzdXBwb3J0c1B1c2hTdGF0ZSAmJiBvcHRpb25zLmZhbGxiYWNrICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuZmFsbGJhY2spIHtcbiAgICBtb2RlID0gJ2hhc2gnO1xuICB9XG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgbW9kZSA9ICdhYnN0cmFjdCc7XG4gIH1cbiAgdGhpcy5tb2RlID0gbW9kZTtcblxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdoaXN0b3J5JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIVE1MNUhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGFzaEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlLCB0aGlzLmZhbGxiYWNrKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYWJzdHJhY3QnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEFic3RyYWN0SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAoXCJpbnZhbGlkIG1vZGU6IFwiICsgbW9kZSkpO1xuICAgICAgfVxuICB9XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjdXJyZW50Um91dGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICByZWRpcmVjdGVkRnJvbVxuKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoZXIubWF0Y2gocmF3LCBjdXJyZW50LCByZWRpcmVjdGVkRnJvbSlcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5jdXJyZW50Um91dGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5jdXJyZW50XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChhcHAgLyogVnVlIGNvbXBvbmVudCBpbnN0YW5jZSAqLykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0KFxuICAgIGluc3RhbGwuaW5zdGFsbGVkLFxuICAgIFwibm90IGluc3RhbGxlZC4gTWFrZSBzdXJlIHRvIGNhbGwgYFZ1ZS51c2UoVnVlUm91dGVyKWAgXCIgK1xuICAgIFwiYmVmb3JlIGNyZWF0aW5nIHJvb3QgaW5zdGFuY2UuXCJcbiAgKTtcblxuICB0aGlzLmFwcHMucHVzaChhcHApO1xuXG4gIC8vIHNldCB1cCBhcHAgZGVzdHJveWVkIGhhbmRsZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1yb3V0ZXIvaXNzdWVzLzI2MzlcbiAgYXBwLiRvbmNlKCdob29rOmRlc3Ryb3llZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjbGVhbiBvdXQgYXBwIGZyb20gdGhpcy5hcHBzIGFycmF5IG9uY2UgZGVzdHJveWVkXG4gICAgdmFyIGluZGV4ID0gdGhpcyQxLmFwcHMuaW5kZXhPZihhcHApO1xuICAgIGlmIChpbmRleCA+IC0xKSB7IHRoaXMkMS5hcHBzLnNwbGljZShpbmRleCwgMSk7IH1cbiAgICAvLyBlbnN1cmUgd2Ugc3RpbGwgaGF2ZSBhIG1haW4gYXBwIG9yIG51bGwgaWYgbm8gYXBwc1xuICAgIC8vIHdlIGRvIG5vdCByZWxlYXNlIHRoZSByb3V0ZXIgc28gaXQgY2FuIGJlIHJldXNlZFxuICAgIGlmICh0aGlzJDEuYXBwID09PSBhcHApIHsgdGhpcyQxLmFwcCA9IHRoaXMkMS5hcHBzWzBdIHx8IG51bGw7IH1cbiAgfSk7XG5cbiAgLy8gbWFpbiBhcHAgcHJldmlvdXNseSBpbml0aWFsaXplZFxuICAvLyByZXR1cm4gYXMgd2UgZG9uJ3QgbmVlZCB0byBzZXQgdXAgbmV3IGhpc3RvcnkgbGlzdGVuZXJcbiAgaWYgKHRoaXMuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmFwcCA9IGFwcDtcblxuICB2YXIgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcblxuICBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhUTUw1SGlzdG9yeSkge1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9IGVsc2UgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIYXNoSGlzdG9yeSkge1xuICAgIHZhciBzZXR1cEhhc2hMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhpc3Rvcnkuc2V0dXBMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKFxuICAgICAgaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSxcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXJcbiAgICApO1xuICB9XG5cbiAgaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgdGhpcyQxLmFwcHMuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7XG4gICAgICBhcHAuX3JvdXRlID0gcm91dGU7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmJlZm9yZUhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlUmVzb2x2ZSA9IGZ1bmN0aW9uIGJlZm9yZVJlc29sdmUgKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5yZXNvbHZlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiBhZnRlckVhY2ggKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5hZnRlckhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiLCBlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uRXJyb3IoZXJyb3JDYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAoIW9uQ29tcGxldGUgJiYgIW9uQWJvcnQgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHRoaXMkMS5oaXN0b3J5LnB1c2gobG9jYXRpb24sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhpc3RvcnkucHVzaChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG4gIH1cbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghb25Db21wbGV0ZSAmJiAhb25BYm9ydCAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdGhpcyQxLmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbiAgfVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gIHRoaXMuaGlzdG9yeS5nbyhuKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uIGJhY2sgKCkge1xuICB0aGlzLmdvKC0xKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIGZvcndhcmQgKCkge1xuICB0aGlzLmdvKDEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nZXRNYXRjaGVkQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGdldE1hdGNoZWRDb21wb25lbnRzICh0bykge1xuICB2YXIgcm91dGUgPSB0b1xuICAgID8gdG8ubWF0Y2hlZFxuICAgICAgPyB0b1xuICAgICAgOiB0aGlzLnJlc29sdmUodG8pLnJvdXRlXG4gICAgOiB0aGlzLmN1cnJlbnRSb3V0ZTtcbiAgaWYgKCFyb3V0ZSkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIHJvdXRlLm1hdGNoZWQubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG0uY29tcG9uZW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBtLmNvbXBvbmVudHNba2V5XVxuICAgIH0pXG4gIH0pKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAoXG4gIHRvLFxuICBjdXJyZW50LFxuICBhcHBlbmRcbikge1xuICBjdXJyZW50ID0gY3VycmVudCB8fCB0aGlzLmhpc3RvcnkuY3VycmVudDtcbiAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24oXG4gICAgdG8sXG4gICAgY3VycmVudCxcbiAgICBhcHBlbmQsXG4gICAgdGhpc1xuICApO1xuICB2YXIgcm91dGUgPSB0aGlzLm1hdGNoKGxvY2F0aW9uLCBjdXJyZW50KTtcbiAgdmFyIGZ1bGxQYXRoID0gcm91dGUucmVkaXJlY3RlZEZyb20gfHwgcm91dGUuZnVsbFBhdGg7XG4gIHZhciBiYXNlID0gdGhpcy5oaXN0b3J5LmJhc2U7XG4gIHZhciBocmVmID0gY3JlYXRlSHJlZihiYXNlLCBmdWxsUGF0aCwgdGhpcy5tb2RlKTtcbiAgcmV0dXJuIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgcm91dGU6IHJvdXRlLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBub3JtYWxpemVkVG86IGxvY2F0aW9uLFxuICAgIHJlc29sdmVkOiByb3V0ZVxuICB9XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFkZFJvdXRlcyA9IGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gIHRoaXMubWF0Y2hlci5hZGRSb3V0ZXMocm91dGVzKTtcbiAgaWYgKHRoaXMuaGlzdG9yeS5jdXJyZW50ICE9PSBTVEFSVCkge1xuICAgIHRoaXMuaGlzdG9yeS50cmFuc2l0aW9uVG8odGhpcy5oaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZ1ZVJvdXRlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiByZWdpc3Rlckhvb2sgKGxpc3QsIGZuKSB7XG4gIGxpc3QucHVzaChmbik7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBsaXN0LmluZGV4T2YoZm4pO1xuICAgIGlmIChpID4gLTEpIHsgbGlzdC5zcGxpY2UoaSwgMSk7IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVIcmVmIChiYXNlLCBmdWxsUGF0aCwgbW9kZSkge1xuICB2YXIgcGF0aCA9IG1vZGUgPT09ICdoYXNoJyA/ICcjJyArIGZ1bGxQYXRoIDogZnVsbFBhdGg7XG4gIHJldHVybiBiYXNlID8gY2xlYW5QYXRoKGJhc2UgKyAnLycgKyBwYXRoKSA6IHBhdGhcbn1cblxuVnVlUm91dGVyLmluc3RhbGwgPSBpbnN0YWxsO1xuVnVlUm91dGVyLnZlcnNpb24gPSAnMy4xLjMnO1xuXG5pZiAoaW5Ccm93c2VyICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UoVnVlUm91dGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVnVlUm91dGVyO1xuIiwiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG5pbXBvcnQgbGlzdFRvU3R5bGVzIGZyb20gJy4vbGlzdFRvU3R5bGVzJ1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cbnZhciBvcHRpb25zID0gbnVsbFxudmFyIHNzcklkS2V5ID0gJ2RhdGEtdnVlLXNzci1pZCdcblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkU3R5bGVzQ2xpZW50IChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbiwgX29wdGlvbnMpIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlWycgKyBzc3JJZEtleSArICd+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuICBpZiAob3B0aW9ucy5zc3JJZCkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoc3NySWRLZXksIG9iai5pZClcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuIiwiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChwYXJlbnRJZCwgbGlzdCkge1xuICB2YXIgc3R5bGVzID0gW11cbiAgdmFyIG5ld1N0eWxlcyA9IHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIHZhciBpZCA9IGl0ZW1bMF1cbiAgICB2YXIgY3NzID0gaXRlbVsxXVxuICAgIHZhciBtZWRpYSA9IGl0ZW1bMl1cbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXVxuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgaWQ6IHBhcmVudElkICsgJzonICsgaSxcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9XG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0geyBpZDogaWQsIHBhcnRzOiBbcGFydF0gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNcbn1cbiIsIi8qIVxuICogVnVlLmpzIHYyLjYuMTFcbiAqIChjKSAyMDE0LTIwMTkgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vLyBUaGVzZSBoZWxwZXJzIHByb2R1Y2UgYmV0dGVyIFZNIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmcuXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlLlxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gKFxuICAgIGlzRGVmKHZhbCkgJiZcbiAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXG4gKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cblxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZuLmJpbmQoY3R4KVxufVxuXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gID8gbmF0aXZlQmluZFxuICA6IHBvbHlmaWxsQmluZDtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxuICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcbiAqIGNvbnRhaW4gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnLFxuICAnc2VydmVyUHJlZmV0Y2gnXG5dO1xuXG4vKiAgKi9cblxuXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdXBkYXRlcyBhc3luY2hyb25vdXNseS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBieSBWdWUgVGVzdCBVdGlsc1xuICAgKiBUaGlzIHdpbGwgc2lnbmlmaWNhbnRseSByZWR1Y2UgcGVyZm9ybWFuY2UgaWYgc2V0IHRvIGZhbHNlLlxuICAgKi9cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG4vKipcbiAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXG4gKiBza2lwcGluZyBcXHUxMDAwMC1cXHVFRkZGRiBkdWUgdG8gaXQgZnJlZXppbmcgdXAgUGhhbnRvbUpTXG4gKi9cbnZhciB1bmljb2RlUmVnRXhwID0gL2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQvO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IG5ldyBSZWdFeHAoKFwiW15cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIi4kX1xcXFxkXVwiKSk7XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBpbldlZXggPSB0eXBlb2YgV1hFbnZpcm9ubWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFXWEVudmlyb25tZW50LnBsYXRmb3JtO1xudmFyIHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSAoVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMCkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbnZhciBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcbnZhciBpc1BoYW50b21KUyA9IFVBICYmIC9waGFudG9tanMvLnRlc3QoVUEpO1xudmFyIGlzRkYgPSBVQSAmJiBVQS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXSAmJiBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICA/IHZtLm9wdGlvbnNcbiAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICA6IHZtO1xuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgLy8gc3VicyBhcmVuJ3Qgc29ydGVkIGluIHNjaGVkdWxlciBpZiBub3QgcnVubmluZyBhc3luY1xuICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVtIG5vdyB0byBtYWtlIHN1cmUgdGhleSBmaXJlIGluIGNvcnJlY3RcbiAgICAvLyBvcmRlclxuICAgIHN1YnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyBUaGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcbi8vIGNhbiBiZSBldmFsdWF0ZWQgYXQgYSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAodGFyZ2V0KSB7XG4gIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgdGFyZ2V0U3RhY2sucG9wKCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zLFxuICBhc3luY0ZhY3Rvcnlcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICAvLyAjNzk3NVxuICAgIC8vIGNsb25lIGNoaWxkcmVuIGFycmF5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGluIGNhc2Ugb2YgY2xvbmluZ1xuICAgIC8vIGEgY2hpbGQuXG4gICAgdm5vZGUuY2hpbGRyZW4gJiYgdm5vZGUuY2hpbGRyZW4uc2xpY2UoKSxcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuXG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dO1xuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xudmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgIHByb3RvQXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG4gIGlmICgoIWdldHRlciB8fCBzZXR0ZXIpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YWwgPSBvYmpba2V5XTtcbiAgfVxuXG4gIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgLy8gIzc5ODE6IGZvciBhY2Nlc3NvciBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVyXG4gICAgICBpZiAoZ2V0dGVyICYmICFzZXR0ZXIpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXG4gIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgPyBSZWZsZWN0Lm93bktleXMoZnJvbSlcbiAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgLy8gaW4gY2FzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgb2JzZXJ2ZWQuLi5cbiAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdG9WYWwgIT09IGZyb21WYWwgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QodG9WYWwpICYmXG4gICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpXG4gICAgKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICB2YXIgcmVzID0gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsO1xuICByZXR1cm4gcmVzXG4gICAgPyBkZWR1cGVIb29rcyhyZXMpXG4gICAgOiByZXNcbn1cblxuZnVuY3Rpb24gZGVkdXBlSG9va3MgKGhvb2tzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XG4gICAgICByZXMucHVzaChob29rc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgaWYgKGNoaWxkVmFsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbkFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cbiAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgcGFyZW50VmFsID0gdW5kZWZpbmVkOyB9XG4gIGlmIChjaGlsZFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgY2hpbGRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXkkMV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5JDFdO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICBpZiAoY2hpbGRWYWwgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBpZiAoY2hpbGRWYWwpIHsgZXh0ZW5kKHJldCwgY2hpbGRWYWwpOyB9XG4gIHJldHVybiByZXRcbn07XG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICBpZiAoIW5ldyBSZWdFeHAoKFwiXlthLXpBLVpdW1xcXFwtXFxcXC4wLTlfXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCJdKiRcIikpLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJ1xuICAgICk7XG4gIH1cbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICdpZDogJyArIG5hbWVcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucywgdm0pIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImluamVjdFxcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShpbmplY3QpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiQkMSA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmJCQxLCB1cGRhdGU6IGRlZiQkMSB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuXG4gIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxuICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgaWYgKCFjaGlsZC5fYmFzZSkge1xuICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICB9XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gc2tpcCB2YWxpZGF0aW9uIGZvciB3ZWV4IHJlY3ljbGUtbGlzdCBjaGlsZCBjb21wb25lbnQgcHJvcHNcbiAgICAhKGZhbHNlKVxuICApIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSk7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgdmFyIGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gXCIgd2l0aCB2YWx1ZSBcIiArIGV4cGVjdGVkVmFsdWU7XG4gIH1cbiAgbWVzc2FnZSArPSBcIiwgZ290IFwiICsgcmVjZWl2ZWRUeXBlICsgXCIgXCI7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIiArIHJlY2VpdmVkVmFsdWUgKyBcIi5cIjtcbiAgfVxuICByZXR1cm4gbWVzc2FnZVxufVxuXG5mdW5jdGlvbiBzdHlsZVZhbHVlICh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICByZXR1cm4gKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIilcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuICAgIHJldHVybiAoXCJcIiArIChOdW1iZXIodmFsdWUpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUgKHZhbHVlKSB7XG4gIHZhciBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbTsgfSlcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuICgpIHtcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWV4L2lzc3Vlcy8xNTA1XG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICBpZiAodm0pIHtcbiAgICAgIHZhciBjdXIgPSB2bTtcbiAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyAoXG4gIGhhbmRsZXIsXG4gIGNvbnRleHQsXG4gIGFyZ3MsXG4gIHZtLFxuICBpbmZvXG4pIHtcbiAgdmFyIHJlcztcbiAgdHJ5IHtcbiAgICByZXMgPSBhcmdzID8gaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKSA6IGhhbmRsZXIuY2FsbChjb250ZXh0KTtcbiAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcbiAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgLy8gaXNzdWUgIzk1MTFcbiAgICAgIC8vIGF2b2lkIGNhdGNoIHRyaWdnZXJpbmcgbXVsdGlwbGUgdGltZXMgd2hlbiBuZXN0ZWQgY2FsbHNcbiAgICAgIHJlcy5faGFuZGxlZCA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG52YXIgdGltZXJGdW5jO1xuXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4vLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIEluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gIHZhciBjb3VudGVyID0gMTtcbiAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICB9KTtcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXG4gIC8vIFRlY2huaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFxcXCIkZGF0YS5cIiArIGtleSArIFwiXFxcIiBiZWNhdXNlIFwiICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzLiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNsb25lZFtpXSwgbnVsbCwgYXJndW1lbnRzJDEsIHZtLCBcInYtb24gaGFuZGxlclwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbnMsIG51bGwsIGFyZ3VtZW50cywgdm0sIFwidi1vbiBoYW5kbGVyXCIpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICBjcmVhdGVPbmNlSGFuZGxlcixcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmJCQxLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgaGFzT3duKHNvdXJjZS5fcHJvdmlkZWQsIHByb3ZpZGVLZXkpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICB2YXIgc2xvdHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xuICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgIGRlbGV0ZSBzbG90c1tuYW1lJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgbm9ybWFsU2xvdHMsXG4gIHByZXZTbG90c1xuKSB7XG4gIHZhciByZXM7XG4gIHZhciBoYXNOb3JtYWxTbG90cyA9IE9iamVjdC5rZXlzKG5vcm1hbFNsb3RzKS5sZW5ndGggPiAwO1xuICB2YXIgaXNTdGFibGUgPSBzbG90cyA/ICEhc2xvdHMuJHN0YWJsZSA6ICFoYXNOb3JtYWxTbG90cztcbiAgdmFyIGtleSA9IHNsb3RzICYmIHNsb3RzLiRrZXk7XG4gIGlmICghc2xvdHMpIHtcbiAgICByZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxuICB9IGVsc2UgaWYgKFxuICAgIGlzU3RhYmxlICYmXG4gICAgcHJldlNsb3RzICYmXG4gICAgcHJldlNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgIGtleSA9PT0gcHJldlNsb3RzLiRrZXkgJiZcbiAgICAhaGFzTm9ybWFsU2xvdHMgJiZcbiAgICAhcHJldlNsb3RzLiRoYXNOb3JtYWxcbiAgKSB7XG4gICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxuICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgIHJldHVybiBwcmV2U2xvdHNcbiAgfSBlbHNlIHtcbiAgICByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBzbG90cykge1xuICAgICAgaWYgKHNsb3RzW2tleSQxXSAmJiBrZXkkMVswXSAhPT0gJyQnKSB7XG4gICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZXhwb3NlIG5vcm1hbCBzbG90cyBvbiBzY29wZWRTbG90c1xuICBmb3IgKHZhciBrZXkkMiBpbiBub3JtYWxTbG90cykge1xuICAgIGlmICghKGtleSQyIGluIHJlcykpIHtcbiAgICAgIHJlc1trZXkkMl0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSQyKTtcbiAgICB9XG4gIH1cbiAgLy8gYXZvcmlheiBzZWVtcyB0byBtb2NrIGEgbm9uLWV4dGVuc2libGUgJHNjb3BlZFNsb3RzIG9iamVjdFxuICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcbiAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgKHNsb3RzKS5fbm9ybWFsaXplZCA9IHJlcztcbiAgfVxuICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgZGVmKHJlcywgJyRrZXknLCBrZXkpO1xuICBkZWYocmVzLCAnJGhhc05vcm1hbCcsIGhhc05vcm1hbFNsb3RzKTtcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XG4gIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID8gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGZuKHt9KTtcbiAgICByZXMgPSByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzKVxuICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcbiAgICByZXR1cm4gcmVzICYmIChcbiAgICAgIHJlcy5sZW5ndGggPT09IDAgfHxcbiAgICAgIChyZXMubGVuZ3RoID09PSAxICYmIHJlc1swXS5pc0NvbW1lbnQpIC8vICM5NjU4XG4gICAgKSA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIG5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV0gfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGlmICghKGNhbWVsaXplZEtleSBpbiBoYXNoKSAmJiAhKGh5cGhlbmF0ZWRLZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlcyxcbiAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XG4gIGhhc0R5bmFtaWNLZXlzLFxuICBjb250ZW50SGFzaEtleVxuKSB7XG4gIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzbG90ID0gZm5zW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNsb3QpKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgcmVzLCBoYXNEeW5hbWljS2V5cyk7XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50SGFzaEtleSkge1xuICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYga2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG51bGwgaXMgYSBzcGVjaWFsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgd2FybihcbiAgICAgICAgKFwiSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogXCIgKyBrZXkpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZU9ialxufVxuXG4vLyBoZWxwZXIgdG8gZHluYW1pY2FsbHkgYXBwZW5kIG1vZGlmaWVyIHJ1bnRpbWUgbWFya2VycyB0byBldmVudCBuYW1lcy5cbi8vIGVuc3VyZSBvbmx5IGFwcGVuZCB3aGVuIHZhbHVlIGlzIGFscmVhZHkgc3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYXN0XG4vLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXIgKHZhbHVlLCBzeW1ib2wpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzeW1ib2wgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xuICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XG4gIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm07XG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICB9XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzJDEuJHNsb3RzKSB7XG4gICAgICBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdGhpcyQxLiRzbG90cyA9IHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMkMS4kc2xvdHNcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywgKHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgfVxuICB9KSk7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcbiAgfVxuICBpZiAoZGF0YS5zbG90KSB7XG4gICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50IC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIHBhcmVudDogcGFyZW50XG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZXhpc3RpbmcgPSBob29rc1trZXldO1xuICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2skMSh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gIHZhciBtZXJnZWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIGZsb3cgY29tcGxhaW5zIGFib3V0IGV4dHJhIGFyZ3Mgd2hpY2ggaXMgd2h5IHdlIHVzZSBhbnlcbiAgICBmMShhLCBiKTtcbiAgICBmMihhLCBiKTtcbiAgfTtcbiAgbWVyZ2VkLl9tZXJnZWQgPSB0cnVlO1xuICByZXR1cm4gbWVyZ2VkXG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcbiAgOyhkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIHZhciBleGlzdGluZyA9IG9uW2V2ZW50XTtcbiAgdmFyIGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXG4gICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEubmF0aXZlT24pKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiVGhlIC5uYXRpdmUgbW9kaWZpZXIgZm9yIHYtb24gaXMgb25seSB2YWxpZCBvbiBjb21wb25lbnRzIGJ1dCBpdCB3YXMgdXNlZCBvbiA8XCIgKyB0YWcgKyBcIj4uXCIpLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKCFkYXRhIHx8ICFkYXRhLnByZSkgJiYgaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG52YXIgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHZtLiRzbG90cyxcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1c2UgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvclxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgdmFyIG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAob3duZXIgJiYgaXNEZWYoZmFjdG9yeS5vd25lcnMpICYmIGZhY3Rvcnkub3duZXJzLmluZGV4T2Yob3duZXIpID09PSAtMSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChvd25lciAmJiAhaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgdmFyIG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgdmFyIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgdmFyIHRpbWVyVGltZW91dCA9IG51bGxcblxuICAgIDsob3duZXIpLiRvbignaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmUob3duZXJzLCBvd25lcik7IH0pO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAodGltZXJMb2FkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZyk7XG4gICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyVGltZW91dCk7XG4gICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChldmVudCwgZm4pIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQ7XG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgIHZtLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKCFmbikge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICB2YXIgaW5mbyA9IFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB7XG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUgKCkge1xuICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cblxuICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZHluYW1pYyBzY29wZWRTbG90cyAoaGFuZC13cml0dGVuIG9yIGNvbXBpbGVkIGJ1dCB3aXRoXG4gIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXG4gIC8vIFwiJHN0YWJsZVwiIG1hcmtlci5cbiAgdmFyIG5ld1Njb3BlZFNsb3RzID0gcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cztcbiAgdmFyIG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xuICB2YXIgaGFzRHluYW1pY1Njb3BlZFNsb3QgPSAhIShcbiAgICAobmV3U2NvcGVkU2xvdHMgJiYgIW5ld1Njb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAobmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkgIT09IG5ld1Njb3BlZFNsb3RzLiRrZXkpXG4gICk7XG5cbiAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAvLyB1cGRhdGUuIER5bmFtaWMgc2NvcGVkIHNsb3RzIG1heSBhbHNvIGhhdmUgY2hhbmdlZC4gSW4gc3VjaCBjYXNlcywgYSBmb3JjZWRcbiAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXG4gIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICB2YXIgaW5mbyA9IGhvb2sgKyBcIiBob29rXCI7XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG52YXIgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbnZhciBnZXROb3cgPSBEYXRlLm5vdztcblxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbi8vIEFsbCBJRSB2ZXJzaW9ucyB1c2UgbG93LXJlcyBldmVudCB0aW1lc3RhbXBzLCBhbmQgaGF2ZSBwcm9ibGVtYXRpYyBjbG9ja1xuLy8gaW1wbGVtZW50YXRpb25zICgjOTYzMilcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUUpIHtcbiAgdmFyIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICBpZiAoXG4gICAgcGVyZm9ybWFuY2UgJiZcbiAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXBcbiAgKSB7XG4gICAgLy8gaWYgdGhlIGV2ZW50IHRpbWVzdGFtcCwgYWx0aG91Z2ggZXZhbHVhdGVkIEFGVEVSIHRoZSBEYXRlLm5vdygpLCBpc1xuICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lciB0aW1lc3RhbXBzIGFzXG4gICAgLy8gd2VsbC5cbiAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgIH1cbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgZmx1c2hTY2hlZHVsZXJRdWV1ZSgpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9ucyxcbiAgaXNSZW5kZXJXYXRjaGVyXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICB9XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgIHZtLFxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHRoaXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIgKyAodHlwZW9mIG1ldGhvZHNba2V5XSkgKyBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnJvciwgdm0sIChcImNhbGxiYWNrIGZvciBpbW1lZGlhdGUgd2F0Y2hlciBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQkMyA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBsYXRlc3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5yZW5kZXJNaXhpbihWdWUpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxuICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBvYnNlcnZlKG9iaik7XG4gICAgcmV0dXJuIG9ialxuICB9O1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxufSk7XG5cblZ1ZS52ZXJzaW9uID0gJzIuNi4xMSc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUgPSBtYWtlTWFwKCdldmVudHMsY2FyZXQsdHlwaW5nLHBsYWludGV4dC1vbmx5Jyk7XG5cbnZhciBjb252ZXJ0RW51bWVyYXRlZFZhbHVlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXG4gICAgPyAnZmFsc2UnXG4gICAgLy8gYWxsb3cgYXJiaXRyYXJ5IHN0cmluZyB2YWx1ZSBmb3IgY29udGVudGVkaXRhYmxlXG4gICAgOiBrZXkgPT09ICdjb250ZW50ZWRpdGFibGUnICYmIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSh2YWx1ZSlcbiAgICAgID8gdmFsdWVcbiAgICAgIDogJ3RydWUnXG59O1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xufVxuXG52YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgdGFnTmFtZTogdGFnTmFtZSxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICBzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAoXG4gICAgb2xkVm5vZGUsXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXgsXG4gICAgcmVtb3ZlT25seVxuICApIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgIHJlbW92ZVZub2Rlcyhbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxuLy8gaW1wbGVtZW50YXRpb24gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzb1xuLy8gc2FmZSB0byBleGNsdWRlLlxudmFyIHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gIGlmICh1c2VNaWNyb3Rhc2tGaXgpIHtcbiAgICB2YXIgYXR0YWNoZWRUaW1lc3RhbXAgPSBjdXJyZW50Rmx1c2hUaW1lc3RhbXA7XG4gICAgdmFyIG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gb3JpZ2luYWwuX3dyYXBwZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKFxuICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAvLyB0aGlzIGlzIGp1c3QgYSBzYWZldHkgbmV0IGluIGNhc2UgZXZlbnQudGltZVN0YW1wIGlzIHVucmVsaWFibGUgaW5cbiAgICAgICAgLy8gY2VydGFpbiB3ZWlyZCBlbnZpcm9ubWVudHMuLi5cbiAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAvLyBldmVudCBpcyBmaXJlZCBhZnRlciBoYW5kbGVyIGF0dGFjaG1lbnRcbiAgICAgICAgZS50aW1lU3RhbXAgPj0gYXR0YWNoZWRUaW1lc3RhbXAgfHxcbiAgICAgICAgLy8gYmFpbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgaGF2ZSBidWdneSBldmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25zXG4gICAgICAgIC8vICM5NDYyIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcbiAgICAgICAgLy8gIzk2ODEgUXRXZWJFbmdpbmUgZXZlbnQudGltZVN0YW1wIGlzIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIGUudGltZVN0YW1wIDw9IDAgfHxcbiAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAvLyBlbGVjdHJvbi9udy5qcyBhcHAsIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCB3aWxsIGJlIHVzaW5nIGEgZGlmZmVyZW50XG4gICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIG5hbWUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIuX3dyYXBwZXIgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbnZhciBzdmdDb250YWluZXI7XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG5cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJiBlbG0udGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmIGlzU1ZHKGVsbS50YWdOYW1lKSAmJiBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XG4gICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgaW5uZXJIVE1MIGZvciBTVkcgZWxlbWVudHNcbiAgICAgIHN2Z0NvbnRhaW5lciA9IHN2Z0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmc+XCIgKyBjdXIgKyBcIjwvc3ZnPlwiO1xuICAgICAgdmFyIHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXG4gICAgICAvLyBgdmFsdWVgIGlzIGhhbmRsZWQgc2VwYXJhdGVseSBiZWNhdXNlIHRoZSBET00gdmFsdWUgbWF5IGJlIHRlbXBvcmFyaWx5XG4gICAgICAvLyBvdXQgb2Ygc3luYyB3aXRoIFZET00gc3RhdGUgZHVlIHRvIGZvY3VzLCBjb21wb3NpdGlvbiBhbmQgbW9kaWZpZXJzLlxuICAgICAgLy8gVGhpcyAgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNhcnJ5IGBjaGVja2VkYCB1cGRhdGUuXG4gICAgICBjdXIgIT09IG9sZFByb3BzW2tleV1cbiAgICApIHtcbiAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcbiAgICAgIC8vIGUuZy4gYHZhbHVlYCBvbiA8cHJvZ3Jlc3M+IHcvIG5vbi1maW5pdGUgdmFsdWVcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUobmFtZSksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxudmFyIHdoaXRlc3BhY2VSRSA9IC9cXHMrLztcblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4vLyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdyAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBkaXJlY3RpdmUgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyAjNjkwM1xuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBpc05vdFRleHROb2RlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfTtcblxudmFyIGlzVlNob3dEaXJlY3RpdmUgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH07XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICBiZWZvcmVNb3VudDogZnVuY3Rpb24gYmVmb3JlTW91bnQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZTtcbiAgICB0aGlzLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHRoaXMkMSk7XG4gICAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgICB0aGlzJDEuX19wYXRjaF9fKFxuICAgICAgICB0aGlzJDEuX3Zub2RlLFxuICAgICAgICB0aGlzJDEua2VwdCxcbiAgICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICAgICk7XG4gICAgICB0aGlzJDEuX3Zub2RlID0gdGhpcyQxLmtlcHQ7XG4gICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgIHVwZGF0ZS5jYWxsKHRoaXMkMSwgdm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCdcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03YmE1YmQ5MCZcIlxudmFyIHNjcmlwdCA9IHt9XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCIvVXNlcnMva2FkZWthZGVydXNoaXJvdS9TaXRlcy9iYWNrbG9nLXRlc3QtMi9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCc3YmE1YmQ5MCcpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCc3YmE1YmQ5MCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCc3YmE1YmQ5MCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03YmE1YmQ5MCZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCc3YmE1YmQ5MCcsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL0FwcC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03YmE1YmQ5MCZcIiIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9nbG9iYWwuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCJkYTI3OWZhYVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZ2xvYmFsLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZ2xvYmFsLnNjc3NcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsImltcG9ydCBcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiXG5pbXBvcnQgVnVlIGZyb20gXCJ2dWVcIlxuaW1wb3J0IEFwcCBmcm9tIFwiLi9BcHAudnVlXCJcbmltcG9ydCByb3V0ZXIgZnJvbSBcIi4vcm91dGVyXCJcbmltcG9ydCBcIi4vYXNzZXRzL2dsb2JhbC5zY3NzXCJcblxubmV3IFZ1ZSh7XG4gIHJvdXRlcixcbiAgcmVuZGVyOiBoID0+IGgoQXBwKSxcbn0pLiRtb3VudChcIiNhcHBcIikiLCJpbXBvcnQgVnVlIGZyb20gXCJ2dWVcIlxuaW1wb3J0IFZ1ZVJvdXRlciBmcm9tIFwidnVlLXJvdXRlclwiXG5cblZ1ZS51c2UoVnVlUm91dGVyKVxuXG5jb25zdCByb3V0ZXMgPSBbXG4gIHsgXG4gICAgcGF0aDogXCIvXCIsXG4gICAgY29tcG9uZW50OiAoKSA9PiBpbXBvcnQoXCIuL0Zvcm1cIilcbiAgfSxcbiAgeyBcbiAgICBuYW1lOiBcImNvbXBsZXRlXCIsXG4gICAgcGF0aDogXCIvY29tcGxldGVcIixcbiAgICBjb21wb25lbnQ6ICgpID0+IGltcG9ydChcIi4vQ29tcGxldGVcIilcbiAgfSxcbiAgeyBcbiAgICBuYW1lOiBcImVycm9yXCIsXG4gICAgcGF0aDogXCIvZXJyb3JcIixcbiAgICBjb21wb25lbnQ6ICgpID0+IGltcG9ydChcIi4vRXJyb3JcIilcbiAgfSxcbiAgeyBcbiAgICBuYW1lOiBcInRlc3RcIixcbiAgICBwYXRoOiBcIi90ZXN0XCIsXG4gICAgY29tcG9uZW50OiAoKSA9PiBpbXBvcnQoXCIuL1Rlc3RcIilcbiAgfVxuXVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgVnVlUm91dGVyKHtcbiAgbW9kZTogXCJoaXN0b3J5XCIsXG4gIHJvdXRlc1xufSkiXSwic291cmNlUm9vdCI6IiJ9